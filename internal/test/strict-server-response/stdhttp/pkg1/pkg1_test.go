// Code generated by generator/generate.go DO NOT EDIT.

package pkg1_test

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"mime"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"net/textproto"
	"net/url"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/oapi-codegen/oapi-codegen/v2/internal/test/strict-server-response/stdhttp/pkg1"
)

type strictServerInterface struct{}

func (s strictServerInterface) TestJSON(ctx context.Context, request pkg1.TestJSONRequestObject) (pkg1.TestJSONResponseObject, error) {
	return pkg1.TestJSONdefaultJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		StatusCode: 200,
	}, nil
}

func TestJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.JSONDefault)
}

func (s strictServerInterface) TestSpecialJSON(ctx context.Context, request pkg1.TestSpecialJSONRequestObject) (pkg1.TestSpecialJSONResponseObject, error) {
	return pkg1.TestSpecialJSONdefaultApplicationTestPlusJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		StatusCode: 200,
	}, nil
}

func TestSpecialJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-special-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestSpecialJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/test+json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.ApplicationtestJSONDefault)
}

func (s strictServerInterface) TestFormdata(ctx context.Context, request pkg1.TestFormdataRequestObject) (pkg1.TestFormdataResponseObject, error) {
	return pkg1.TestFormdatadefaultFormdataResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		StatusCode: 200,
	}, nil
}

func TestFormdata(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-formdata", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFormdataWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/x-www-form-urlencoded", res.HTTPResponse.Header.Get("Content-Type"))
	form, err := url.ParseQuery(string(res.Body))
	assert.NoError(t, err)
	assert.Equal(t, url.Values{
		"field1": []string{"bar"},
		"field2": []string{"456"},
	}, form)
}

func (s strictServerInterface) TestMultipart(ctx context.Context, request pkg1.TestMultipartRequestObject) (pkg1.TestMultipartResponseObject, error) {
	return pkg1.TestMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		StatusCode: 200,
	}, nil
}

func TestMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/form-data", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestMultipartRelated(ctx context.Context, request pkg1.TestMultipartRelatedRequestObject) (pkg1.TestMultipartRelatedResponseObject, error) {
	return pkg1.TestMultipartRelateddefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		StatusCode: 200,
	}, nil
}

func TestMultipartRelated(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-multipart-related", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestMultipartRelatedWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/related", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestOther(ctx context.Context, request pkg1.TestOtherRequestObject) (pkg1.TestOtherResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestOtherdefaultApplicationtestResponse{
		Body:          bytes.NewReader(buf),
		StatusCode:    200,
		ContentLength: int64(len(buf)),
	}, nil
}

func TestOther(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-other", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestOtherWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/test", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestWildcard(ctx context.Context, request pkg1.TestWildcardRequestObject) (pkg1.TestWildcardResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestWildcarddefaultApplicationResponse{
		Body:          bytes.NewReader(buf),
		StatusCode:    200,
		ContentType:   "application/baz",
		ContentLength: int64(len(buf)),
	}, nil
}

func TestWildcard(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-wildcard", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestWildcardWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/baz", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestNoContent(ctx context.Context, request pkg1.TestNoContentRequestObject) (pkg1.TestNoContentResponseObject, error) {
	return pkg1.TestNoContentdefaultResponse{
		StatusCode: 204,
	}, nil
}

func TestNoContent(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-nocontent", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestNoContentWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 204, res.StatusCode())
	assert.Equal(t, "", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte{}, res.Body)
}

func (s strictServerInterface) TestFixedJSON(ctx context.Context, request pkg1.TestFixedJSONRequestObject) (pkg1.TestFixedJSONResponseObject, error) {
	return pkg1.TestFixedJSON200JSONResponse(pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}), nil
}

func TestFixedJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.JSON200)
}

func (s strictServerInterface) TestFixedSpecialJSON(ctx context.Context, request pkg1.TestFixedSpecialJSONRequestObject) (pkg1.TestFixedSpecialJSONResponseObject, error) {
	return pkg1.TestFixedSpecialJSON200ApplicationTestPlusJSONResponse(pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}), nil
}

func TestFixedSpecialJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-special-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedSpecialJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/test+json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.ApplicationtestJSON200)
}

func (s strictServerInterface) TestFixedFormdata(ctx context.Context, request pkg1.TestFixedFormdataRequestObject) (pkg1.TestFixedFormdataResponseObject, error) {
	return pkg1.TestFixedFormdata200FormdataResponse(pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}), nil
}

func TestFixedFormdata(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-formdata", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedFormdataWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/x-www-form-urlencoded", res.HTTPResponse.Header.Get("Content-Type"))
	form, err := url.ParseQuery(string(res.Body))
	assert.NoError(t, err)
	assert.Equal(t, url.Values{
		"field1": []string{"bar"},
		"field2": []string{"456"},
	}, form)
}

func (s strictServerInterface) TestFixedMultipart(ctx context.Context, request pkg1.TestFixedMultipartRequestObject) (pkg1.TestFixedMultipartResponseObject, error) {
	return pkg1.TestFixedMultipart200MultipartResponse(func(writer *multipart.Writer) error {
		if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
			return err
		} else {
			return json.NewEncoder(p).Encode(pkg1.TestSchema{
				Field1: "bar",
				Field2: 456,
			})
		}
	}), nil
}

func TestFixedMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/form-data", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestFixedMultipartRelated(ctx context.Context, request pkg1.TestFixedMultipartRelatedRequestObject) (pkg1.TestFixedMultipartRelatedResponseObject, error) {
	return pkg1.TestFixedMultipartRelated200MultipartResponse(func(writer *multipart.Writer) error {
		if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
			return err
		} else {
			return json.NewEncoder(p).Encode(pkg1.TestSchema{
				Field1: "bar",
				Field2: 456,
			})
		}
	}), nil
}

func TestFixedMultipartRelated(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-multipart-related", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedMultipartRelatedWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/related", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestFixedOther(ctx context.Context, request pkg1.TestFixedOtherRequestObject) (pkg1.TestFixedOtherResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestFixedOther200ApplicationtestResponse{
		Body:          bytes.NewReader(buf),
		ContentLength: int64(len(buf)),
	}, nil
}

func TestFixedOther(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-other", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedOtherWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/test", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestFixedWildcard(ctx context.Context, request pkg1.TestFixedWildcardRequestObject) (pkg1.TestFixedWildcardResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestFixedWildcard200ApplicationResponse{
		Body:          bytes.NewReader(buf),
		ContentType:   "application/baz",
		ContentLength: int64(len(buf)),
	}, nil
}

func TestFixedWildcard(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-wildcard", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedWildcardWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/baz", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestFixedNoContent(ctx context.Context, request pkg1.TestFixedNoContentRequestObject) (pkg1.TestFixedNoContentResponseObject, error) {
	return pkg1.TestFixedNoContent204Response{}, nil
}

func TestFixedNoContent(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-fixed-nocontent", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestFixedNoContentWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 204, res.StatusCode())
	assert.Equal(t, "", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte{}, res.Body)
}

func (s strictServerInterface) TestHeaderJSON(ctx context.Context, request pkg1.TestHeaderJSONRequestObject) (pkg1.TestHeaderJSONResponseObject, error) {
	return pkg1.TestHeaderJSONdefaultJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestHeaderJSONdefaultResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestHeaderJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.JSONDefault)
}

func (s strictServerInterface) TestHeaderSpecialJSON(ctx context.Context, request pkg1.TestHeaderSpecialJSONRequestObject) (pkg1.TestHeaderSpecialJSONResponseObject, error) {
	return pkg1.TestHeaderSpecialJSONdefaultApplicationTestPlusJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestHeaderSpecialJSONdefaultResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestHeaderSpecialJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-special-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderSpecialJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/test+json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.ApplicationtestJSONDefault)
}

func (s strictServerInterface) TestHeaderFormdata(ctx context.Context, request pkg1.TestHeaderFormdataRequestObject) (pkg1.TestHeaderFormdataResponseObject, error) {
	return pkg1.TestHeaderFormdatadefaultFormdataResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestHeaderFormdatadefaultResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestHeaderFormdata(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-formdata", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFormdataWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/x-www-form-urlencoded", res.HTTPResponse.Header.Get("Content-Type"))
	form, err := url.ParseQuery(string(res.Body))
	assert.NoError(t, err)
	assert.Equal(t, url.Values{
		"field1": []string{"bar"},
		"field2": []string{"456"},
	}, form)
}

func (s strictServerInterface) TestHeaderMultipart(ctx context.Context, request pkg1.TestHeaderMultipartRequestObject) (pkg1.TestHeaderMultipartResponseObject, error) {
	return pkg1.TestHeaderMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestHeaderMultipartdefaultResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestHeaderMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/form-data", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestHeaderMultipartRelated(ctx context.Context, request pkg1.TestHeaderMultipartRelatedRequestObject) (pkg1.TestHeaderMultipartRelatedResponseObject, error) {
	return pkg1.TestHeaderMultipartRelateddefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestHeaderMultipartRelateddefaultResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestHeaderMultipartRelated(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-multipart-related", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderMultipartRelatedWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/related", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestHeaderOther(ctx context.Context, request pkg1.TestHeaderOtherRequestObject) (pkg1.TestHeaderOtherResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestHeaderOtherdefaultApplicationtestResponse{
		Body: bytes.NewReader(buf),
		Headers: pkg1.TestHeaderOtherdefaultResponseHeaders{
			Header2: 123,
		},
		StatusCode:    200,
		ContentLength: int64(len(buf)),
	}, nil
}

func TestHeaderOther(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-other", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderOtherWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/test", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestHeaderWildcard(ctx context.Context, request pkg1.TestHeaderWildcardRequestObject) (pkg1.TestHeaderWildcardResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestHeaderWildcarddefaultApplicationResponse{
		Body: bytes.NewReader(buf),
		Headers: pkg1.TestHeaderWildcarddefaultResponseHeaders{
			Header2: 123,
		},
		StatusCode:    200,
		ContentType:   "application/baz",
		ContentLength: int64(len(buf)),
	}, nil
}

func TestHeaderWildcard(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-wildcard", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderWildcardWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/baz", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestHeaderFixedJSON(ctx context.Context, request pkg1.TestHeaderFixedJSONRequestObject) (pkg1.TestHeaderFixedJSONResponseObject, error) {
	return pkg1.TestHeaderFixedJSON200JSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestHeaderFixedJSON200ResponseHeaders{
			Header2: 123,
		},
	}, nil
}

func TestHeaderFixedJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-fixed-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFixedJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.JSON200)
}

func (s strictServerInterface) TestHeaderFixedSpecialJSON(ctx context.Context, request pkg1.TestHeaderFixedSpecialJSONRequestObject) (pkg1.TestHeaderFixedSpecialJSONResponseObject, error) {
	return pkg1.TestHeaderFixedSpecialJSON200ApplicationTestPlusJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestHeaderFixedSpecialJSON200ResponseHeaders{
			Header2: 123,
		},
	}, nil
}

func TestHeaderFixedSpecialJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-fixed-special-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFixedSpecialJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/test+json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.ApplicationtestJSON200)
}

func (s strictServerInterface) TestHeaderFixedFormdata(ctx context.Context, request pkg1.TestHeaderFixedFormdataRequestObject) (pkg1.TestHeaderFixedFormdataResponseObject, error) {
	return pkg1.TestHeaderFixedFormdata200FormdataResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestHeaderFixedFormdata200ResponseHeaders{
			Header2: 123,
		},
	}, nil
}

func TestHeaderFixedFormdata(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-fixed-formdata", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFixedFormdataWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/x-www-form-urlencoded", res.HTTPResponse.Header.Get("Content-Type"))
	form, err := url.ParseQuery(string(res.Body))
	assert.NoError(t, err)
	assert.Equal(t, url.Values{
		"field1": []string{"bar"},
		"field2": []string{"456"},
	}, form)
}

func (s strictServerInterface) TestHeaderFixedMultipart(ctx context.Context, request pkg1.TestHeaderFixedMultipartRequestObject) (pkg1.TestHeaderFixedMultipartResponseObject, error) {
	return pkg1.TestHeaderFixedMultipart200MultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestHeaderFixedMultipart200ResponseHeaders{
			Header2: 123,
		},
	}, nil
}

func TestHeaderFixedMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-fixed-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFixedMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/form-data", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestHeaderFixedMultipartRelated(ctx context.Context, request pkg1.TestHeaderFixedMultipartRelatedRequestObject) (pkg1.TestHeaderFixedMultipartRelatedResponseObject, error) {
	return pkg1.TestHeaderFixedMultipartRelated200MultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestHeaderFixedMultipartRelated200ResponseHeaders{
			Header2: 123,
		},
	}, nil
}

func TestHeaderFixedMultipartRelated(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-fixed-multipart-related", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFixedMultipartRelatedWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/related", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestHeaderFixedOther(ctx context.Context, request pkg1.TestHeaderFixedOtherRequestObject) (pkg1.TestHeaderFixedOtherResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestHeaderFixedOther200ApplicationtestResponse{
		Body: bytes.NewReader(buf),
		Headers: pkg1.TestHeaderFixedOther200ResponseHeaders{
			Header2: 123,
		},
		ContentLength: int64(len(buf)),
	}, nil
}

func TestHeaderFixedOther(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-fixed-other", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFixedOtherWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/test", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestHeaderFixedWildcard(ctx context.Context, request pkg1.TestHeaderFixedWildcardRequestObject) (pkg1.TestHeaderFixedWildcardResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestHeaderFixedWildcard200ApplicationResponse{
		Body: bytes.NewReader(buf),
		Headers: pkg1.TestHeaderFixedWildcard200ResponseHeaders{
			Header2: 123,
		},
		ContentType:   "application/baz",
		ContentLength: int64(len(buf)),
	}, nil
}

func TestHeaderFixedWildcard(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-header-fixed-wildcard", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestHeaderFixedWildcardWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/baz", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestRefJSON(ctx context.Context, request pkg1.TestRefJSONRequestObject) (pkg1.TestRefJSONResponseObject, error) {
	return pkg1.TestRefJSONdefaultJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		StatusCode: 200,
	}, nil
}

func TestRefJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.JSONDefault)
}

func (s strictServerInterface) TestRefSpecialJSON(ctx context.Context, request pkg1.TestRefSpecialJSONRequestObject) (pkg1.TestRefSpecialJSONResponseObject, error) {
	return pkg1.TestRefSpecialJSONdefaultApplicationTestPlusJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		StatusCode: 200,
	}, nil
}

func TestRefSpecialJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-special-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefSpecialJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/test+json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.ApplicationtestJSONDefault)
}

func (s strictServerInterface) TestRefMultipart(ctx context.Context, request pkg1.TestRefMultipartRequestObject) (pkg1.TestRefMultipartResponseObject, error) {
	return pkg1.TestRefMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		StatusCode: 200,
	}, nil
}

func TestRefMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/form-data", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefMultipartRelated(ctx context.Context, request pkg1.TestRefMultipartRelatedRequestObject) (pkg1.TestRefMultipartRelatedResponseObject, error) {
	return pkg1.TestRefMultipartRelateddefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		StatusCode: 200,
	}, nil
}

func TestRefMultipartRelated(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-multipart-related", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefMultipartRelatedWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/related", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefOther(ctx context.Context, request pkg1.TestRefOtherRequestObject) (pkg1.TestRefOtherResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestRefOtherdefaultApplicationtestResponse{
		Body:          bytes.NewReader(buf),
		StatusCode:    200,
		ContentLength: int64(len(buf)),
	}, nil
}

func TestRefOther(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-other", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefOtherWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/test", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestRefWildcard(ctx context.Context, request pkg1.TestRefWildcardRequestObject) (pkg1.TestRefWildcardResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestRefWildcarddefaultApplicationResponse{
		Body:          bytes.NewReader(buf),
		StatusCode:    200,
		ContentType:   "application/baz",
		ContentLength: int64(len(buf)),
	}, nil
}

func TestRefWildcard(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-wildcard", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefWildcardWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/baz", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestRefNoContent(ctx context.Context, request pkg1.TestRefNoContentRequestObject) (pkg1.TestRefNoContentResponseObject, error) {
	return pkg1.TestRefNoContentdefaultResponse{
		StatusCode: 204,
	}, nil
}

func TestRefNoContent(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-nocontent", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefNoContentWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 204, res.StatusCode())
	assert.Equal(t, "", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte{}, res.Body)
}

func (s strictServerInterface) TestRefFixedJSON(ctx context.Context, request pkg1.TestRefFixedJSONRequestObject) (pkg1.TestRefFixedJSONResponseObject, error) {
	return pkg1.TestRefFixedJSON200JSONResponse{pkg1.TestRespRefFixedJSONJSONResponse(pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	})}, nil
}

func TestRefFixedJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-fixed-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefFixedJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.JSON200)
}

func (s strictServerInterface) TestRefFixedSpecialJSON(ctx context.Context, request pkg1.TestRefFixedSpecialJSONRequestObject) (pkg1.TestRefFixedSpecialJSONResponseObject, error) {
	return pkg1.TestRefFixedSpecialJSON200ApplicationTestPlusJSONResponse{pkg1.TestRespRefFixedSpecialJSONApplicationTestPlusJSONResponse(pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	})}, nil
}

func TestRefFixedSpecialJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-fixed-special-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefFixedSpecialJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/test+json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.ApplicationtestJSON200)
}

func (s strictServerInterface) TestRefFixedMultipart(ctx context.Context, request pkg1.TestRefFixedMultipartRequestObject) (pkg1.TestRefFixedMultipartResponseObject, error) {
	return pkg1.TestRefFixedMultipart200MultipartResponse(pkg1.TestRespRefFixedMultipartMultipartResponse(func(writer *multipart.Writer) error {
		if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
			return err
		} else {
			return json.NewEncoder(p).Encode(pkg1.TestSchema{
				Field1: "bar",
				Field2: 456,
			})
		}
	})), nil
}

func TestRefFixedMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-fixed-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefFixedMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/form-data", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefFixedMultipartRelated(ctx context.Context, request pkg1.TestRefFixedMultipartRelatedRequestObject) (pkg1.TestRefFixedMultipartRelatedResponseObject, error) {
	return pkg1.TestRefFixedMultipartRelated200MultipartResponse(pkg1.TestRespRefFixedMultipartRelatedMultipartResponse(func(writer *multipart.Writer) error {
		if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
			return err
		} else {
			return json.NewEncoder(p).Encode(pkg1.TestSchema{
				Field1: "bar",
				Field2: 456,
			})
		}
	})), nil
}

func TestRefFixedMultipartRelated(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-fixed-multipart-related", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefFixedMultipartRelatedWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/related", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefFixedOther(ctx context.Context, request pkg1.TestRefFixedOtherRequestObject) (pkg1.TestRefFixedOtherResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestRefFixedOther200ApplicationtestResponse{pkg1.TestRespRefFixedOtherApplicationtestResponse{
		Body:          bytes.NewReader(buf),
		ContentLength: int64(len(buf)),
	}}, nil
}

func TestRefFixedOther(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-fixed-other", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefFixedOtherWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/test", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestRefFixedWildcard(ctx context.Context, request pkg1.TestRefFixedWildcardRequestObject) (pkg1.TestRefFixedWildcardResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestRefFixedWildcard200ApplicationResponse{pkg1.TestRespRefFixedWildcardApplicationResponse{
		Body:          bytes.NewReader(buf),
		ContentType:   "application/baz",
		ContentLength: int64(len(buf)),
	}}, nil
}

func TestRefFixedWildcard(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-fixed-wildcard", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefFixedWildcardWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	assert.Equal(t, "application/baz", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestRefFixedNoContent(ctx context.Context, request pkg1.TestRefFixedNoContentRequestObject) (pkg1.TestRefFixedNoContentResponseObject, error) {
	return pkg1.TestRespRefFixedNoContentResponse{}, nil
}

func TestRefFixedNoContent(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-fixed-nocontent", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefFixedNoContentWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 204, res.StatusCode())
	assert.Equal(t, "", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte{}, res.Body)
}

func (s strictServerInterface) TestRefHeaderJSON(ctx context.Context, request pkg1.TestRefHeaderJSONRequestObject) (pkg1.TestRefHeaderJSONResponseObject, error) {
	return pkg1.TestRefHeaderJSONdefaultJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestRespRefHeaderJSONResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestRefHeaderJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.JSONDefault)
}

func (s strictServerInterface) TestRefHeaderSpecialJSON(ctx context.Context, request pkg1.TestRefHeaderSpecialJSONRequestObject) (pkg1.TestRefHeaderSpecialJSONResponseObject, error) {
	return pkg1.TestRefHeaderSpecialJSONdefaultApplicationTestPlusJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestRespRefHeaderSpecialJSONResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestRefHeaderSpecialJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-special-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderSpecialJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/test+json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.ApplicationtestJSONDefault)
}

func (s strictServerInterface) TestRefHeaderMultipart(ctx context.Context, request pkg1.TestRefHeaderMultipartRequestObject) (pkg1.TestRefHeaderMultipartResponseObject, error) {
	return pkg1.TestRefHeaderMultipartdefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestRespRefHeaderMultipartResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestRefHeaderMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/form-data", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefHeaderMultipartRelated(ctx context.Context, request pkg1.TestRefHeaderMultipartRelatedRequestObject) (pkg1.TestRefHeaderMultipartRelatedResponseObject, error) {
	return pkg1.TestRefHeaderMultipartRelateddefaultMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestRespRefHeaderMultipartRelatedResponseHeaders{
			Header2: 123,
		},
		StatusCode: 200,
	}, nil
}

func TestRefHeaderMultipartRelated(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-multipart-related", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderMultipartRelatedWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/related", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefHeaderOther(ctx context.Context, request pkg1.TestRefHeaderOtherRequestObject) (pkg1.TestRefHeaderOtherResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestRefHeaderOtherdefaultApplicationtestResponse{
		Body: bytes.NewReader(buf),
		Headers: pkg1.TestRespRefHeaderOtherResponseHeaders{
			Header2: 123,
		},
		StatusCode:    200,
		ContentLength: int64(len(buf)),
	}, nil
}

func TestRefHeaderOther(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-other", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderOtherWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/test", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestRefHeaderWildcard(ctx context.Context, request pkg1.TestRefHeaderWildcardRequestObject) (pkg1.TestRefHeaderWildcardResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestRefHeaderWildcarddefaultApplicationResponse{
		Body: bytes.NewReader(buf),
		Headers: pkg1.TestRespRefHeaderWildcardResponseHeaders{
			Header2: 123,
		},
		StatusCode:    200,
		ContentType:   "application/baz",
		ContentLength: int64(len(buf)),
	}, nil
}

func TestRefHeaderWildcard(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-wildcard", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderWildcardWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/baz", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestRefHeaderFixedJSON(ctx context.Context, request pkg1.TestRefHeaderFixedJSONRequestObject) (pkg1.TestRefHeaderFixedJSONResponseObject, error) {
	return pkg1.TestRefHeaderFixedJSON200JSONResponse{pkg1.TestRespRefHeaderFixedJSONJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestRespRefHeaderFixedJSONResponseHeaders{
			Header2: 123,
		},
	}}, nil
}

func TestRefHeaderFixedJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-fixed-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderFixedJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.JSON200)
}

func (s strictServerInterface) TestRefHeaderFixedSpecialJSON(ctx context.Context, request pkg1.TestRefHeaderFixedSpecialJSONRequestObject) (pkg1.TestRefHeaderFixedSpecialJSONResponseObject, error) {
	return pkg1.TestRefHeaderFixedSpecialJSON200ApplicationTestPlusJSONResponse{pkg1.TestRespRefHeaderFixedSpecialJSONApplicationTestPlusJSONResponse{
		Body: pkg1.TestSchema{
			Field1: "bar",
			Field2: 456,
		},
		Headers: pkg1.TestRespRefHeaderFixedSpecialJSONResponseHeaders{
			Header2: 123,
		},
	}}, nil
}

func TestRefHeaderFixedSpecialJSON(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-fixed-special-json", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderFixedSpecialJSONWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/test+json", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, &pkg1.TestSchema{
		Field1: "bar",
		Field2: 456,
	}, res.ApplicationtestJSON200)
}

func (s strictServerInterface) TestRefHeaderFixedMultipart(ctx context.Context, request pkg1.TestRefHeaderFixedMultipartRequestObject) (pkg1.TestRefHeaderFixedMultipartResponseObject, error) {
	return pkg1.TestRefHeaderFixedMultipart200MultipartResponse{pkg1.TestRespRefHeaderFixedMultipartMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestRespRefHeaderFixedMultipartResponseHeaders{
			Header2: 123,
		},
	}}, nil
}

func TestRefHeaderFixedMultipart(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-fixed-multipart", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderFixedMultipartWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/form-data", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefHeaderFixedMultipartRelated(ctx context.Context, request pkg1.TestRefHeaderFixedMultipartRelatedRequestObject) (pkg1.TestRefHeaderFixedMultipartRelatedResponseObject, error) {
	return pkg1.TestRefHeaderFixedMultipartRelated200MultipartResponse{pkg1.TestRespRefHeaderFixedMultipartRelatedMultipartResponse{
		Body: func(writer *multipart.Writer) error {
			if p, err := writer.CreatePart(textproto.MIMEHeader{"Content-Type": []string{"application/json"}}); err != nil {
				return err
			} else {
				return json.NewEncoder(p).Encode(pkg1.TestSchema{
					Field1: "bar",
					Field2: 456,
				})
			}
		},
		Headers: pkg1.TestRespRefHeaderFixedMultipartRelatedResponseHeaders{
			Header2: 123,
		},
	}}, nil
}

func TestRefHeaderFixedMultipartRelated(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-fixed-multipart-related", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderFixedMultipartRelatedWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	mediaType, params, err := mime.ParseMediaType(res.HTTPResponse.Header.Get("Content-Type"))
	if assert.NoError(t, err) {
		assert.Equal(t, "multipart/related", mediaType)
		assert.NotEmpty(t, params["boundary"])
		reader := multipart.NewReader(bytes.NewReader(res.Body), params["boundary"])
		jsonExist := false
		for {
			if p, err := reader.NextPart(); err == io.EOF {
				break
			} else {
				assert.NoError(t, err)
				switch p.Header.Get("Content-Type") {
				case "application/json":
					var j pkg1.TestSchema
					err := json.NewDecoder(p).Decode(&j)
					assert.NoError(t, err)
					assert.Equal(t, pkg1.TestSchema{
						Field1: "bar",
						Field2: 456,
					}, j)
					jsonExist = true
				default:
					assert.Fail(t, "Bad Content-Type: %s", p.Header.Get("Content-Type"))
				}
			}
		}
		assert.True(t, jsonExist)
	}
}

func (s strictServerInterface) TestRefHeaderFixedOther(ctx context.Context, request pkg1.TestRefHeaderFixedOtherRequestObject) (pkg1.TestRefHeaderFixedOtherResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestRefHeaderFixedOther200ApplicationtestResponse{pkg1.TestRespRefHeaderFixedOtherApplicationtestResponse{
		Body: bytes.NewReader(buf),
		Headers: pkg1.TestRespRefHeaderFixedOtherResponseHeaders{
			Header2: 123,
		},
		ContentLength: int64(len(buf)),
	}}, nil
}

func TestRefHeaderFixedOther(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-fixed-other", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderFixedOtherWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/test", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}

func (s strictServerInterface) TestRefHeaderFixedWildcard(ctx context.Context, request pkg1.TestRefHeaderFixedWildcardRequestObject) (pkg1.TestRefHeaderFixedWildcardResponseObject, error) {
	buf := []byte("bar")
	return pkg1.TestRefHeaderFixedWildcard200ApplicationResponse{pkg1.TestRespRefHeaderFixedWildcardApplicationResponse{
		Body: bytes.NewReader(buf),
		Headers: pkg1.TestRespRefHeaderFixedWildcardResponseHeaders{
			Header2: 123,
		},
		ContentType:   "application/baz",
		ContentLength: int64(len(buf)),
	}}, nil
}

func TestRefHeaderFixedWildcard(t *testing.T) {
	hh := pkg1.Handler(pkg1.NewStrictHandler(strictServerInterface{}, nil))

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !assert.Equal(t, "/test-ref-header-fixed-wildcard", r.URL.Path) {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		hh.ServeHTTP(w, r)
	}))
	defer ts.Close()

	c, err := pkg1.NewClientWithResponses(ts.URL)
	assert.NoError(t, err)
	res, err := c.TestRefHeaderFixedWildcardWithResponse(context.TODO())
	assert.NoError(t, err)
	assert.Equal(t, 200, res.StatusCode())
	// assert.Empty(t, res.HTTPResponse.Header.Values("header1"))
	assert.Equal(t, []string{"123"}, res.HTTPResponse.Header.Values("header2"))
	assert.Equal(t, "application/baz", res.HTTPResponse.Header.Get("Content-Type"))
	assert.Equal(t, []byte("bar"), res.Body)
}
