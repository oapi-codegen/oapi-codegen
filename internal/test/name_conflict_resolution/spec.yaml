openapi: 3.0.1

info:
  title: "Comprehensive name collision resolution test"
  description: |
    Exercises all documented name collision patterns across issues and PRs:
    #200, #254, #255, #292, #407, #899, #1357, #1450, #1474, #1713, #1881, #2097, #2213
    Also covers oapi-codegen-exp#14 (inline response object with $ref properties).
  version: 0.0.0

paths:
  # Pattern A: Cross-section collision (issues #200, #254, #407, #1881, PR #292)
  # "Bar" appears in schemas, parameters, requestBodies, responses, and headers.
  /foo:
    post:
      operationId: postFoo
      parameters:
        - $ref: '#/components/parameters/Bar'
      requestBody:
        $ref: '#/components/requestBodies/Bar'
      responses:
        200:
          $ref: '#/components/responses/Bar'

  # Pattern B: Schema vs client wrapper (issues #1474, #1713, #1450)
  # Schema "CreateItemResponse" collides with createItem wrapper.
  /items:
    post:
      operationId: createItem
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateItemResponse'

    # Pattern C: Schema alias vs client wrapper (issue #1357)
    # Schema "ListItemsResponse" (string alias) collides with listItems wrapper.
    get:
      operationId: listItems
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListItemsResponse'

  # Pattern D: Operation name = schema response name (issue #255)
  # Schema "QueryResponse" collides with query wrapper.
  /query:
    post:
      operationId: query
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                q:
                  type: string
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QueryResponse'

  # Pattern E: Schema matches op+Response (issues #2097, #899)
  # Schema "GetStatusResponse" collides with getStatus wrapper.
  /status:
    get:
      operationId: getStatus
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetStatusResponse'

  # Pattern F: x-go-type-name extension + cross-section collision
  # Schema "Qux" has x-go-type-name and collides with response "Qux".
  /qux:
    get:
      operationId: getQux
      responses:
        '200':
          $ref: '#/components/responses/Qux'
    post:
      operationId: postQux
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Qux'
      responses:
        '200':
          description: OK

  # Pattern G: x-go-type extension + cross-section collision
  # Schema "Zap" has x-go-type and collides with response "Zap".
  /zap:
    get:
      operationId: getZap
      responses:
        '200':
          $ref: '#/components/responses/Zap'
    post:
      operationId: postZap
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Zap'
      responses:
        '200':
          description: OK

  # Pattern H: Multiple JSON content types in requestBody (PR #2213)
  # "Order" appears in schemas and requestBodies. The requestBody has 3 content
  # types that all contain "json" and collapse to the same "JSON" short name:
  #   application/json, application/merge-patch+json, application/json-patch+json
  # This triggers an infinite oscillation between context suffix and content type
  # suffix strategies unless the numeric fallback can break the cycle.
  /orders:
    post:
      operationId: createOrder
      requestBody:
        $ref: '#/components/requestBodies/Order'
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'

  # Pattern I: Inline response object with $ref properties to x-go-type schemas
  # (oapi-codegen-exp#14). The response has an inline object with properties that
  # $ref component schemas carrying x-go-type. Each property ref should use the
  # component schema's type alias, not produce duplicate type declarations.
  /entities:
    get:
      operationId: listEntities
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/Widget'
                  metadata:
                    $ref: '#/components/schemas/Metadata'

  # Pattern J: Duplicate inline oneOf members across response content types
  # A PATCH operation returns multiple JSON content types
  # (application/json, application/json-patch+json, application/json-patch-query+json,
  # application/merge-patch+json). The json-patch and json-patch-query variants
  # share an identical oneOf schema with inline (non-$ref) members. The codegen
  # must not emit duplicate type declarations for those inline members.
  #
  # Additionally, the requestBody shares the same name as a component schema
  # ("Resource_MVO") where the requestBody content schemas $ref the component
  # schema, and one content type $refs a different schema.
  /resources/{id}:
    patch:
      operationId: patchResource
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      requestBody:
        $ref: '#/components/requestBodies/Resource_MVO'
      responses:
        '200':
          $ref: '#/components/responses/200Resource_Patch'

  # Cross-section: requestBody vs schema (issues #254, #407)
  # "Pet" appears in both schemas and requestBodies.
  /pets:
    post:
      operationId: createPet
      requestBody:
        $ref: '#/components/requestBodies/Pet'
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Pet'

components:
  schemas:
    Bar:
      type: object
      properties:
        value:
          type: string

    Bar2:
      type: object
      properties:
        value:
          type: number

    CreateItemResponse:
      type: object
      properties:
        id:
          type: string
        name:
          type: string

    ListItemsResponse:
      type: string

    QueryResponse:
      type: object
      properties:
        results:
          type: array
          items:
            type: string

    GetStatusResponse:
      type: object
      properties:
        status:
          type: string
        timestamp:
          type: string

    # Pattern H: Schema "Order" collides with requestBody "Order" which has
    # 3 content types that all map to the "JSON" short name.
    Order:
      type: object
      properties:
        id:
          type: string
        product:
          type: string

    Pet:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string

    # Pattern I: schemas with x-go-type used as $ref targets in inline response properties.
    # (oapi-codegen-exp#14)
    Widget:
      type: object
      x-go-type: string
      properties:
        id:
          type: string

    Metadata:
      type: object
      x-go-type: string
      properties:
        total:
          type: integer

    # Pattern J: schema "Resource_MVO" collides with requestBody "Resource_MVO".
    # The requestBody's content schemas $ref the component schema, plus one
    # content type $refs a different schema (JsonPatch). The response for the
    # PATCH operation has multiple JSON content types, two of which share an
    # identical oneOf schema with inline members.
    Resource_MVO:
      type: object
      properties:
        name:
          type: string
        status:
          type: string

    Resource:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        status:
          type: string

    JsonPatch:
      type: array
      items:
        type: object
        properties:
          op:
            type: string
          path:
            type: string

    # Pattern F: x-go-type-name extension + cross-section collision
    # Schema "Qux" has x-go-type-name: CustomQux and collides with response "Qux".
    Qux:
      type: object
      x-go-type-name: CustomQux
      properties:
        label:
          type: string

    # Pattern G: x-go-type extension + cross-section collision
    # Schema "Zap" has x-go-type: string and collides with response "Zap".
    Zap:
      type: object
      x-go-type: string
      properties:
        unused:
          type: string

  parameters:
    Bar:
      name: bar
      in: query
      schema:
        type: string

  requestBodies:
    Bar:
      content:
        application/json:
          schema:
            type: object
            properties:
              value:
                type: integer

    # Pattern H: requestBody "Order" with 3 content types that all contain "json"
    # and collapse to the same "JSON" suffix via contentTypeSuffix().
    Order:
      content:
        application/json:
          schema:
            type: object
            properties:
              id:
                type: string
              product:
                type: string
        application/merge-patch+json:
          schema:
            type: object
            properties:
              product:
                type: string
        application/json-patch+json:
          schema:
            type: array
            items:
              type: object
              properties:
                op:
                  type: string
                path:
                  type: string
                value:
                  type: string

    Pet:
      content:
        application/json:
          schema:
            type: object
            properties:
              name:
                type: string
              species:
                type: string

    # Pattern J: requestBody "Resource_MVO" shares name with schema "Resource_MVO".
    # Content schemas $ref the component schema, except json-patch which $refs JsonPatch.
    Resource_MVO:
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Resource_MVO'
        application/merge-patch+json:
          schema:
            $ref: '#/components/schemas/Resource_MVO'
        application/json-patch+json:
          schema:
            $ref: '#/components/schemas/JsonPatch'

  headers:
    Bar:
      schema:
        type: boolean

  responses:
    Bar:
      description: Bar response
      headers:
        X-Bar:
          $ref: '#/components/headers/Bar'
      content:
        application/json:
          schema:
            type: object
            properties:
              value1:
                $ref: '#/components/schemas/Bar'
              value2:
                $ref: '#/components/schemas/Bar2'

    Qux:
      description: A Qux response
      content:
        application/json:
          schema:
            type: object
            properties:
              data:
                type: string

    Zap:
      description: A Zap response
      content:
        application/json:
          schema:
            type: object
            properties:
              result:
                type: string

    # Pattern J: response with multiple JSON content types where json-patch
    # and json-patch-query variants share an identical oneOf schema with
    # inline (non-$ref) members. The codegen must not emit duplicate type
    # declarations for those inline members.
    200Resource_Patch:
      description: Patch success
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Resource'
        application/merge-patch+json:
          schema:
            $ref: '#/components/schemas/Resource'
        application/json-patch+json:
          schema:
            oneOf:
              - $ref: '#/components/schemas/Resource'
              - type: array
                items:
                  $ref: '#/components/schemas/Resource'
              - type: string
                nullable: true
        application/json-patch-query+json:
          schema:
            oneOf:
              - $ref: '#/components/schemas/Resource'
              - type: array
                items:
                  $ref: '#/components/schemas/Resource'
              - type: string
                nullable: true
