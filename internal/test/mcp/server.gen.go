// Package mcp provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	mcp "github.com/modelcontextprotocol/go-sdk/mcp"
)

// NewPet defines model for NewPet.
type NewPet struct {
	Name string  `json:"name"`
	Tag  *string `json:"tag,omitempty"`
}

// Pet defines model for Pet.
type Pet struct {
	Id   string  `json:"id"`
	Name string  `json:"name"`
	Tag  *string `json:"tag,omitempty"`
}

// GetPetParams defines parameters for GetPet.
type GetPetParams struct {
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// CreatePetJSONRequestBody defines body for CreatePet for application/json ContentType.
type CreatePetJSONRequestBody = NewPet

// MCPHandlerInterface represents all MCP tool handlers.
type MCPHandlerInterface interface {
	// Get a pet by ID
	// (GET /pets/{petId})
	GetPet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
	// Create a new pet
	// (POST /pets/{petId})
	CreatePet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
}

// MCPServer is the interface that an MCP server must implement.
// *mcp.Server from github.com/modelcontextprotocol/go-sdk/mcp satisfies this interface.
type MCPServer interface {
	AddTool(t *mcp.Tool, h mcp.ToolHandler)
}

const inputSchemaGetPet = "{\"properties\":{\"path\":{\"properties\":{\"petId\":{\"type\":\"string\"}},\"required\":[\"petId\"],\"type\":\"object\"},\"query\":{\"properties\":{\"include\":{\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"path\"],\"type\":\"object\"}"
const outputSchemaGetPet = "{\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"tag\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\"],\"type\":\"object\"}"
const inputSchemaCreatePet = "{\"properties\":{\"body\":{\"properties\":{\"name\":{\"type\":\"string\"},\"tag\":{\"type\":\"string\"}},\"required\":[\"name\"],\"type\":\"object\"},\"path\":{\"properties\":{\"petId\":{\"type\":\"string\"}},\"required\":[\"petId\"],\"type\":\"object\"}},\"required\":[\"path\",\"body\"],\"type\":\"object\"}"
const outputSchemaCreatePet = "{\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"tag\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\"],\"type\":\"object\"}"

// RegisterMCPTools registers all tool handlers with the MCP server.
// The mcpServer parameter should be a *mcp.Server from github.com/modelcontextprotocol/go-sdk/mcp.
// The si parameter implements MCPHandlerInterface with your business logic.
func RegisterMCPTools(mcpServer MCPServer, si MCPHandlerInterface) error {
	// Register GetPet
	{
		tool := &mcp.Tool{
			Name:         "GetPet",
			Description:  "Get a pet by ID",
			InputSchema:  json.RawMessage(inputSchemaGetPet),
			OutputSchema: json.RawMessage(outputSchemaGetPet),
		}

		handler := func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return si.GetPet(ctx, req)
		}

		mcpServer.AddTool(tool, handler)
	}
	// Register CreatePet
	{
		tool := &mcp.Tool{
			Name:         "CreatePet",
			Description:  "Create a new pet",
			InputSchema:  json.RawMessage(inputSchemaCreatePet),
			OutputSchema: json.RawMessage(outputSchemaCreatePet),
		}

		handler := func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return si.CreatePet(ctx, req)
		}

		mcpServer.AddTool(tool, handler)
	}

	return nil
}

type StrictMCPHandlerFunc = func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
type StrictMCPMiddlewareFunc = func(f StrictMCPHandlerFunc, operationID string) StrictMCPHandlerFunc

type StrictMCPServerOptions struct {
	RequestErrorHandlerFunc  func(ctx context.Context, err error) *mcp.CallToolResult
	ResponseErrorHandlerFunc func(ctx context.Context, err error) *mcp.CallToolResult
}

func NewStrictMCPHandler(ssi StrictServerInterface, middlewares []StrictMCPMiddlewareFunc) MCPHandlerInterface {
	return &strictMCPHandler{
		ssi:         ssi,
		middlewares: middlewares,
		options: StrictMCPServerOptions{
			RequestErrorHandlerFunc: func(ctx context.Context, err error) *mcp.CallToolResult {
				return &mcp.CallToolResult{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Request error: %v", err),
						},
					},
					IsError: true,
				}
			},
			ResponseErrorHandlerFunc: func(ctx context.Context, err error) *mcp.CallToolResult {
				return &mcp.CallToolResult{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Response error: %v", err),
						},
					},
					IsError: true,
				}
			},
		},
	}
}

func NewStrictMCPHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMCPMiddlewareFunc, options StrictMCPServerOptions) MCPHandlerInterface {
	return &strictMCPHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictMCPHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMCPMiddlewareFunc
	options     StrictMCPServerOptions
}

// GetPet operation middleware
func (sh *strictMCPHandler) GetPet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var strictRequest GetPetRequestObject

	// Unmarshal MCP request arguments into strict RequestObject
	// MCP uses nested structure: {"path": {...}, "query": {...}, "body": {...}}
	// but strict interface uses flat structure with direct path params and Params field
	if request.Params.Arguments != nil {
		// Parse the nested MCP structure
		var mcpArgs struct {
			Path   map[string]interface{} `json:"path"`
			Query  map[string]interface{} `json:"query,omitempty"`
			Header map[string]interface{} `json:"header,omitempty"`
			Cookie map[string]interface{} `json:"cookie,omitempty"`
		}

		argsBytes, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error marshaling arguments: %w", err)), nil
		}
		if err := json.Unmarshal(argsBytes, &mcpArgs); err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error unmarshaling arguments: %w", err)), nil
		}

		// Map path parameters directly to RequestObject fields
		if val, ok := mcpArgs.Path["petId"]; ok {
			if strVal, ok := val.(string); ok {
				strictRequest.PetId = strVal
			}
		}
		// Map query/header/cookie parameters to Params struct
		paramsData := make(map[string]interface{})
		for k, v := range mcpArgs.Query {
			paramsData[k] = v
		}
		for k, v := range mcpArgs.Header {
			paramsData[k] = v
		}
		for k, v := range mcpArgs.Cookie {
			paramsData[k] = v
		}
		if len(paramsData) > 0 {
			paramsBytes, _ := json.Marshal(paramsData)
			json.Unmarshal(paramsBytes, &strictRequest.Params)
		}
	}

	handler := func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		response, err := sh.ssi.GetPet(ctx, strictRequest)
		if err != nil {
			return nil, err
		}

		// Return response as StructuredContent to comply with MCP output schema requirements
		result := &mcp.CallToolResult{}
		if response != nil {
			result.StructuredContent = response
		}
		return result, nil
	}

	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPet")
	}

	return handler(ctx, request)
}

// CreatePet operation middleware
func (sh *strictMCPHandler) CreatePet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var strictRequest CreatePetRequestObject

	// Unmarshal MCP request arguments into strict RequestObject
	// MCP uses nested structure: {"path": {...}, "query": {...}, "body": {...}}
	// but strict interface uses flat structure with direct path params and Params field
	if request.Params.Arguments != nil {
		// Parse the nested MCP structure
		var mcpArgs struct {
			Path map[string]interface{} `json:"path"`
			Body interface{}            `json:"body,omitempty"`
		}

		argsBytes, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error marshaling arguments: %w", err)), nil
		}
		if err := json.Unmarshal(argsBytes, &mcpArgs); err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error unmarshaling arguments: %w", err)), nil
		}

		// Map path parameters directly to RequestObject fields
		if val, ok := mcpArgs.Path["petId"]; ok {
			if strVal, ok := val.(string); ok {
				strictRequest.PetId = strVal
			}
		}
		// Map body
		if mcpArgs.Body != nil {
			bodyBytes, _ := json.Marshal(mcpArgs.Body)
			json.Unmarshal(bodyBytes, &strictRequest.Body)
		}
	}

	handler := func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		response, err := sh.ssi.CreatePet(ctx, strictRequest)
		if err != nil {
			return nil, err
		}

		// Return response as StructuredContent to comply with MCP output schema requirements
		result := &mcp.CallToolResult{}
		if response != nil {
			result.StructuredContent = response
		}
		return result, nil
	}

	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePet")
	}

	return handler(ctx, request)
}

type GetPetRequestObject struct {
	PetId  string `json:"petId"`
	Params GetPetParams
}

type GetPetResponseObject interface {
	VisitGetPetResponse(w http.ResponseWriter) error
}

type GetPet200JSONResponse Pet

func (response GetPet200JSONResponse) VisitGetPetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreatePetRequestObject struct {
	PetId string `json:"petId"`
	Body  *CreatePetJSONRequestBody
}

type CreatePetResponseObject interface {
	VisitCreatePetResponse(w http.ResponseWriter) error
}

type CreatePet201JSONResponse Pet

func (response CreatePet201JSONResponse) VisitCreatePetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Get a pet by ID
	// (GET /pets/{petId})
	GetPet(ctx context.Context, request GetPetRequestObject) (GetPetResponseObject, error)
	// Create a new pet
	// (POST /pets/{petId})
	CreatePet(ctx context.Context, request CreatePetRequestObject) (CreatePetResponseObject, error)
}
