// Package withprops provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0-00010101000000-000000000000 DO NOT EDIT.
package withprops

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/oapi-codegen/runtime"
)

// Defines values for TestOneKind.
const (
	One TestOneKind = "one"
)

// Defines values for TestTwoKind.
const (
	Two TestTwoKind = "two"
)

// Test defines model for test.
type Test struct {
	Id    int    `json:"id"`
	Kind  string `json:"kind"`
	union json.RawMessage
}

// TestCommon defines model for test_common.
type TestCommon struct {
	Id int `json:"id"`
}

// TestOne defines model for test_one.
type TestOne struct {
	Age  *int        `json:"age,omitempty"`
	Id   int         `json:"id"`
	Kind TestOneKind `json:"kind"`
	Name string      `json:"name"`
}

// TestOneKind defines model for TestOne.Kind.
type TestOneKind string

// TestTwo defines model for test_two.
type TestTwo struct {
	Id   int          `json:"id"`
	Kind *TestTwoKind `json:"kind,omitempty"`
}

// TestTwoKind defines model for TestTwo.Kind.
type TestTwoKind string

// AsTestOne returns the union data inside the Test as a TestOne
func (t Test) AsTestOne() (TestOne, error) {
	var body TestOne
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTestOne overwrites any union data inside the Test as the provided TestOne
func (t *Test) FromTestOne(v TestOne) error {
	t.Kind = "one"

	b, err := json.Marshal(v)
	t.union = b
	if err != nil {
		return err
	}
	return json.Unmarshal(b, t)
}

// MergeTestOne performs a merge with any union data inside the Test, using the provided TestOne
func (t *Test) MergeTestOne(v TestOne) error {
	t.Kind = "one"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTestTwo returns the union data inside the Test as a TestTwo
func (t Test) AsTestTwo() (TestTwo, error) {
	var body TestTwo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTestTwo overwrites any union data inside the Test as the provided TestTwo
func (t *Test) FromTestTwo(v TestTwo) error {
	t.Kind = "two"

	b, err := json.Marshal(v)
	t.union = b
	if err != nil {
		return err
	}
	return json.Unmarshal(b, t)
}

// MergeTestTwo performs a merge with any union data inside the Test, using the provided TestTwo
func (t *Test) MergeTestTwo(v TestTwo) error {
	t.Kind = "two"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Test) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Test) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "one":
		return t.AsTestOne()
	case "two":
		return t.AsTestTwo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Test) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["kind"], err = json.Marshal(t.Kind)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'kind': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Test) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}
