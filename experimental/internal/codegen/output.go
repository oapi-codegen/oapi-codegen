package codegen

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"golang.org/x/tools/imports"
)

// Output collects generated Go code and formats it.
type Output struct {
	packageName string
	imports     map[string]string // path -> alias
	types       []string          // type definitions in order
}

// NewOutput creates a new output collector.
func NewOutput(packageName string) *Output {
	return &Output{
		packageName: packageName,
		imports:     make(map[string]string),
	}
}

// AddImport adds an import path with optional alias.
func (o *Output) AddImport(path, alias string) {
	if path == "" {
		return
	}
	o.imports[path] = alias
}

// AddImports adds multiple imports from a map.
func (o *Output) AddImports(imports map[string]string) {
	for path, alias := range imports {
		o.AddImport(path, alias)
	}
}

// AddType adds a type definition to the output.
func (o *Output) AddType(code string) {
	if code != "" {
		o.types = append(o.types, code)
	}
}

// String generates the complete Go source file.
func (o *Output) String() string {
	var buf bytes.Buffer

	// Generated code header (tells linters to skip this file)
	buf.WriteString("// Code generated by oapi-codegen; DO NOT EDIT.\n\n")

	// Package declaration
	fmt.Fprintf(&buf, "package %s\n\n", o.packageName)

	// Imports
	if len(o.imports) > 0 {
		buf.WriteString("import (\n")
		paths := make([]string, 0, len(o.imports))
		for path := range o.imports {
			paths = append(paths, path)
		}
		sort.Strings(paths)

		for _, path := range paths {
			alias := o.imports[path]
			if alias != "" {
				fmt.Fprintf(&buf, "\t%s %q\n", alias, path)
			} else {
				fmt.Fprintf(&buf, "\t%q\n", path)
			}
		}
		buf.WriteString(")\n\n")
	}

	// Types
	for _, t := range o.types {
		buf.WriteString(t)
		buf.WriteString("\n\n")
	}

	return buf.String()
}

// Format returns the formatted Go source code with imports organized.
func (o *Output) Format() (string, error) {
	src := o.String()
	formatted, err := imports.Process("", []byte(src), nil)
	if err != nil {
		return src, fmt.Errorf("formatting output: %w (source:\n%s)", err, src)
	}
	return string(formatted), nil
}

// CodeBuilder helps construct Go code fragments.
type CodeBuilder struct {
	buf    bytes.Buffer
	indent int
}

// NewCodeBuilder creates a new code builder.
func NewCodeBuilder() *CodeBuilder {
	return &CodeBuilder{}
}

// Indent increases indentation.
func (b *CodeBuilder) Indent() {
	b.indent++
}

// Dedent decreases indentation.
func (b *CodeBuilder) Dedent() {
	if b.indent > 0 {
		b.indent--
	}
}

// Line writes a line with current indentation.
func (b *CodeBuilder) Line(format string, args ...any) {
	for i := 0; i < b.indent; i++ {
		b.buf.WriteByte('\t')
	}
	if len(args) > 0 {
		fmt.Fprintf(&b.buf, format, args...)
	} else {
		b.buf.WriteString(format)
	}
	b.buf.WriteByte('\n')
}

// BlankLine writes an empty line.
func (b *CodeBuilder) BlankLine() {
	b.buf.WriteByte('\n')
}

// Raw writes raw text without indentation or newline.
func (b *CodeBuilder) Raw(s string) {
	b.buf.WriteString(s)
}

// String returns the built code.
func (b *CodeBuilder) String() string {
	return b.buf.String()
}

// GenerateStruct generates a struct type definition.
func GenerateStruct(name string, fields []StructField, doc string, tagGen *StructTagGenerator) string {
	b := NewCodeBuilder()

	// Type documentation
	if doc != "" {
		for _, line := range strings.Split(doc, "\n") {
			b.Line("// %s", line)
		}
	}

	b.Line("type %s struct {", name)
	b.Indent()

	for _, f := range fields {
		tag := generateFieldTag(f, tagGen)
		if f.Doc != "" {
			for _, line := range strings.Split(f.Doc, "\n") {
				line = strings.TrimRight(line, " \t")
				b.Line("// %s", line)
			}
		}
		b.Line("%s %s %s", f.Name, f.Type, tag)
	}

	b.Dedent()
	b.Line("}")

	return b.String()
}

// generateFieldTag generates the struct tag for a field.
func generateFieldTag(f StructField, tagGen *StructTagGenerator) string {
	if tagGen == nil {
		if f.JSONIgnore {
			return "`json:\"-\"`"
		}
		return FormatJSONTag(f.JSONName, f.OmitEmpty)
	}
	info := StructTagInfo{
		FieldName:   f.JSONName,
		GoFieldName: f.Name,
		IsOptional:  !f.Required,
		IsNullable:  f.Nullable,
		IsPointer:   f.Pointer,
		OmitEmpty:   f.OmitEmpty,
		OmitZero:    f.OmitZero,
		JSONIgnore:  f.JSONIgnore,
	}
	return tagGen.GenerateTags(info)
}

// GenerateStructWithAdditionalProps generates a struct with AdditionalProperties field
// and custom marshal/unmarshal methods.
func GenerateStructWithAdditionalProps(name string, fields []StructField, addPropsType string, doc string, tagGen *StructTagGenerator) string {
	b := NewCodeBuilder()

	// Type documentation
	if doc != "" {
		for _, line := range strings.Split(doc, "\n") {
			b.Line("// %s", line)
		}
	}

	b.Line("type %s struct {", name)
	b.Indent()

	// Regular fields
	for _, f := range fields {
		tag := generateFieldTag(f, tagGen)
		b.Line("%s %s %s", f.Name, f.Type, tag)
	}

	// AdditionalProperties field
	b.Line("AdditionalProperties map[string]%s `json:\"-\"`", addPropsType)

	b.Dedent()
	b.Line("}")

	return b.String()
}

// GenerateTypeAlias generates a type alias definition.
func GenerateTypeAlias(name, targetType, doc string) string {
	b := NewCodeBuilder()

	if doc != "" {
		for _, line := range strings.Split(doc, "\n") {
			b.Line("// %s", line)
		}
	}

	b.Line("type %s = %s", name, targetType)

	return b.String()
}

// GenerateEnumFromInfo generates an enum type with const values using pre-computed EnumInfo.
// The EnumInfo contains sanitized names and the prefix decision from collision detection.
func GenerateEnumFromInfo(info *EnumInfo) string {
	b := NewCodeBuilder()

	if info.Doc != "" {
		for _, line := range strings.Split(info.Doc, "\n") {
			b.Line("// %s", line)
		}
	}

	b.Line("type %s %s", info.TypeName, info.BaseType)
	b.BlankLine()

	if len(info.Values) > 0 {
		b.Line("const (")
		b.Indent()

		for i, v := range info.Values {
			var constName string
			if info.PrefixTypeName {
				constName = info.TypeName + info.SanitizedNames[i]
			} else {
				constName = info.SanitizedNames[i]
			}

			if info.BaseType == "string" {
				b.Line("%s %s = %q", constName, info.TypeName, v)
			} else {
				b.Line("%s %s = %s", constName, info.TypeName, v)
			}
		}

		b.Dedent()
		b.Line(")")
	}

	return b.String()
}

// GenerateUnionType generates a union struct for anyOf/oneOf with marshal/unmarshal.
func GenerateUnionType(name string, members []UnionMember, isOneOf bool, doc string) string {
	b := NewCodeBuilder()

	if doc != "" {
		for _, line := range strings.Split(doc, "\n") {
			b.Line("// %s", line)
		}
	}

	// Generate struct with pointer field for each member
	b.Line("type %s struct {", name)
	b.Indent()

	for _, m := range members {
		b.Line("%s *%s", m.FieldName, m.TypeName)
	}

	b.Dedent()
	b.Line("}")

	return b.String()
}

// UnionMember represents a member of a union type (anyOf/oneOf).
type UnionMember struct {
	FieldName        string // Go field name
	TypeName         string // Go type name
	Index            int    // Position in anyOf/oneOf array
	HasApplyDefaults bool   // Whether this type has an ApplyDefaults method
}

// isPrimitiveType returns true if the type is a Go primitive or collection
// that doesn't have an ApplyDefaults method.
func isPrimitiveType(typeName string) bool {
	switch typeName {
	case "string", "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "bool", "any":
		return true
	default:
		// Slices and maps don't have ApplyDefaults
		if strings.HasPrefix(typeName, "[]") || strings.HasPrefix(typeName, "map[") {
			return true
		}
		return false
	}
}

// GenerateUnionApplyDefaults generates ApplyDefaults for a union type.
// It recurses into non-nil members that have ApplyDefaults.
func GenerateUnionApplyDefaults(name string, members []UnionMember) string {
	b := NewCodeBuilder()

	b.Line("// ApplyDefaults sets default values for fields that are nil.")
	b.Line("func (u *%s) ApplyDefaults() {", name)
	b.Indent()

	for _, m := range members {
		// Only recurse into types that have ApplyDefaults
		if m.HasApplyDefaults {
			b.Line("if u.%s != nil {", m.FieldName)
			b.Indent()
			b.Line("u.%s.ApplyDefaults()", m.FieldName)
			b.Dedent()
			b.Line("}")
		}
	}

	b.Dedent()
	b.Line("}")

	return b.String()
}

// GenerateUnionMarshalOneOf generates MarshalJSON for a oneOf type.
func GenerateUnionMarshalOneOf(name string, members []UnionMember) string {
	b := NewCodeBuilder()

	b.Line("func (u %s) MarshalJSON() ([]byte, error) {", name)
	b.Indent()

	b.Line("var count int")
	b.Line("var data []byte")
	b.Line("var err error")
	b.BlankLine()

	for _, m := range members {
		b.Line("if u.%s != nil {", m.FieldName)
		b.Indent()
		b.Line("count++")
		b.Line("data, err = json.Marshal(u.%s)", m.FieldName)
		b.Line("if err != nil {")
		b.Indent()
		b.Line("return nil, err")
		b.Dedent()
		b.Line("}")
		b.Dedent()
		b.Line("}")
	}

	b.BlankLine()
	b.Line("if count != 1 {")
	b.Indent()
	b.Line("return nil, fmt.Errorf(\"%s: exactly one member must be set, got %%d\", count)", name)
	b.Dedent()
	b.Line("}")
	b.BlankLine()
	b.Line("return data, nil")

	b.Dedent()
	b.Line("}")

	return b.String()
}

// GenerateUnionUnmarshalOneOf generates UnmarshalJSON for a oneOf type.
func GenerateUnionUnmarshalOneOf(name string, members []UnionMember) string {
	b := NewCodeBuilder()

	b.Line("func (u *%s) UnmarshalJSON(data []byte) error {", name)
	b.Indent()

	b.Line("var successCount int")
	b.BlankLine()

	for _, m := range members {
		b.Line("var v%d %s", m.Index, m.TypeName)
		b.Line("if err := json.Unmarshal(data, &v%d); err == nil {", m.Index)
		b.Indent()
		b.Line("u.%s = &v%d", m.FieldName, m.Index)
		b.Line("successCount++")
		b.Dedent()
		b.Line("}")
		b.BlankLine()
	}

	b.Line("if successCount != 1 {")
	b.Indent()
	b.Line("return fmt.Errorf(\"%s: expected exactly one type to match, got %%d\", successCount)", name)
	b.Dedent()
	b.Line("}")
	b.BlankLine()
	b.Line("return nil")

	b.Dedent()
	b.Line("}")

	return b.String()
}

// GenerateUnionMarshalAnyOf generates MarshalJSON for an anyOf type.
func GenerateUnionMarshalAnyOf(name string, members []UnionMember) string {
	b := NewCodeBuilder()

	b.Line("func (u %s) MarshalJSON() ([]byte, error) {", name)
	b.Indent()

	// Check if any members are objects (need field merging)
	hasObjects := false
	for _, m := range members {
		if !isPrimitiveType(m.TypeName) {
			hasObjects = true
			break
		}
	}

	if hasObjects {
		// Merge object fields
		b.Line("result := make(map[string]any)")
		b.BlankLine()

		for _, m := range members {
			b.Line("if u.%s != nil {", m.FieldName)
			b.Indent()
			if isPrimitiveType(m.TypeName) {
				// For primitives, we can't merge - just return the value
				b.Line("return json.Marshal(u.%s)", m.FieldName)
			} else {
				b.Line("data, err := json.Marshal(u.%s)", m.FieldName)
				b.Line("if err != nil {")
				b.Indent()
				b.Line("return nil, err")
				b.Dedent()
				b.Line("}")
				b.Line("var m map[string]any")
				b.Line("if err := json.Unmarshal(data, &m); err == nil {")
				b.Indent()
				b.Line("for k, v := range m {")
				b.Indent()
				b.Line("result[k] = v")
				b.Dedent()
				b.Line("}")
				b.Dedent()
				b.Line("}")
			}
			b.Dedent()
			b.Line("}")
		}

		b.BlankLine()
		b.Line("return json.Marshal(result)")
	} else {
		// All primitives - marshal the first non-nil one
		for _, m := range members {
			b.Line("if u.%s != nil {", m.FieldName)
			b.Indent()
			b.Line("return json.Marshal(u.%s)", m.FieldName)
			b.Dedent()
			b.Line("}")
		}
		b.Line("return []byte(\"null\"), nil")
	}

	b.Dedent()
	b.Line("}")

	return b.String()
}

// GenerateUnionUnmarshalAnyOf generates UnmarshalJSON for an anyOf type.
func GenerateUnionUnmarshalAnyOf(name string, members []UnionMember) string {
	b := NewCodeBuilder()

	b.Line("func (u *%s) UnmarshalJSON(data []byte) error {", name)
	b.Indent()

	for _, m := range members {
		b.Line("var v%d %s", m.Index, m.TypeName)
		b.Line("if err := json.Unmarshal(data, &v%d); err == nil {", m.Index)
		b.Indent()
		b.Line("u.%s = &v%d", m.FieldName, m.Index)
		b.Dedent()
		b.Line("}")
		b.BlankLine()
	}

	b.Line("return nil")

	b.Dedent()
	b.Line("}")

	return b.String()
}

// GenerateMixedPropertiesMarshal generates MarshalJSON for structs with additionalProperties.
func GenerateMixedPropertiesMarshal(name string, fields []StructField) string {
	b := NewCodeBuilder()

	b.Line("func (s %s) MarshalJSON() ([]byte, error) {", name)
	b.Indent()

	b.Line("result := make(map[string]any)")
	b.BlankLine()

	// Copy known fields
	for _, f := range fields {
		if f.Pointer {
			b.Line("if s.%s != nil {", f.Name)
			b.Indent()
			b.Line("result[%q] = s.%s", f.JSONName, f.Name)
			b.Dedent()
			b.Line("}")
		} else {
			b.Line("result[%q] = s.%s", f.JSONName, f.Name)
		}
	}

	b.BlankLine()
	b.Line("// Add additional properties")
	b.Line("for k, v := range s.AdditionalProperties {")
	b.Indent()
	b.Line("result[k] = v")
	b.Dedent()
	b.Line("}")
	b.BlankLine()
	b.Line("return json.Marshal(result)")

	b.Dedent()
	b.Line("}")

	return b.String()
}

// GenerateApplyDefaults generates an ApplyDefaults method for a struct.
// It sets default values for fields that are nil and have defaults defined,
// and recursively calls ApplyDefaults on nested struct fields.
// For external types, it uses reflection to check for ApplyDefaults since
// we cannot know at code generation time whether the external type has the method.
// Always generates the method (even if empty) so it can be called uniformly.
// Returns the generated code and whether the reflect package is needed.
func GenerateApplyDefaults(name string, fields []StructField) (string, bool) {
	b := NewCodeBuilder()
	needsReflect := false

	b.Line("// ApplyDefaults sets default values for fields that are nil.")
	b.Line("func (s *%s) ApplyDefaults() {", name)
	b.Indent()

	for _, f := range fields {
		// Apply defaults to nil pointer fields
		if f.Default != "" && f.Pointer {
			b.Line("if s.%s == nil {", f.Name)
			b.Indent()
			// Get the base type (without *)
			baseType := strings.TrimPrefix(f.Type, "*")
			// Check if we need an explicit type conversion for numeric types
			// This is needed because Go infers float64 for floating point literals
			// and int for integer literals, which may not match the target type
			if needsTypeConversion(baseType) {
				b.Line("v := %s(%s)", baseType, f.Default)
			} else {
				b.Line("v := %s", f.Default)
			}
			b.Line("s.%s = &v", f.Name)
			b.Dedent()
			b.Line("}")
		}

		// Recursively apply defaults to struct fields
		if f.IsStruct && f.Pointer {
			b.Line("if s.%s != nil {", f.Name)
			b.Indent()
			b.Line("s.%s.ApplyDefaults()", f.Name)
			b.Dedent()
			b.Line("}")
		}

		// For external types, use reflection to call ApplyDefaults if it exists
		if f.IsExternal && f.Pointer {
			needsReflect = true
			b.Line("if s.%s != nil {", f.Name)
			b.Indent()
			b.Line("if m := reflect.ValueOf(s.%s).MethodByName(\"ApplyDefaults\"); m.IsValid() {", f.Name)
			b.Indent()
			b.Line("m.Call(nil)")
			b.Dedent()
			b.Line("}")
			b.Dedent()
			b.Line("}")
		}
	}

	b.Dedent()
	b.Line("}")

	return b.String(), needsReflect
}

// needsTypeConversion returns true if a numeric type needs an explicit conversion
// from the default Go literal type (int for integers, float64 for floats).
func needsTypeConversion(goType string) bool {
	switch goType {
	case "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32":
		return true
	default:
		return false
	}
}

// GenerateMixedPropertiesUnmarshal generates UnmarshalJSON for structs with additionalProperties.
func GenerateMixedPropertiesUnmarshal(name string, fields []StructField, addPropsType string) string {
	b := NewCodeBuilder()

	b.Line("func (s *%s) UnmarshalJSON(data []byte) error {", name)
	b.Indent()

	// Build set of known field names
	b.Line("// Known fields")
	b.Line("knownFields := map[string]bool{")
	b.Indent()
	for _, f := range fields {
		b.Line("%q: true,", f.JSONName)
	}
	b.Dedent()
	b.Line("}")
	b.BlankLine()

	// Unmarshal into a map first
	b.Line("var raw map[string]json.RawMessage")
	b.Line("if err := json.Unmarshal(data, &raw); err != nil {")
	b.Indent()
	b.Line("return err")
	b.Dedent()
	b.Line("}")
	b.BlankLine()

	// Unmarshal known fields
	for _, f := range fields {
		b.Line("if v, ok := raw[%q]; ok {", f.JSONName)
		b.Indent()
		if f.Pointer {
			b.Line("var val %s", strings.TrimPrefix(f.Type, "*"))
			b.Line("if err := json.Unmarshal(v, &val); err != nil {")
			b.Indent()
			b.Line("return err")
			b.Dedent()
			b.Line("}")
			b.Line("s.%s = &val", f.Name)
		} else {
			b.Line("if err := json.Unmarshal(v, &s.%s); err != nil {", f.Name)
			b.Indent()
			b.Line("return err")
			b.Dedent()
			b.Line("}")
		}
		b.Dedent()
		b.Line("}")
	}

	b.BlankLine()
	b.Line("// Collect additional properties")
	b.Line("s.AdditionalProperties = make(map[string]%s)", addPropsType)
	b.Line("for k, v := range raw {")
	b.Indent()
	b.Line("if !knownFields[k] {")
	b.Indent()
	b.Line("var val %s", addPropsType)
	b.Line("if err := json.Unmarshal(v, &val); err != nil {")
	b.Indent()
	b.Line("return err")
	b.Dedent()
	b.Line("}")
	b.Line("s.AdditionalProperties[k] = val")
	b.Dedent()
	b.Line("}")
	b.Dedent()
	b.Line("}")
	b.BlankLine()
	b.Line("return nil")

	b.Dedent()
	b.Line("}")

	return b.String()
}
