{{/* StylePipeDelimitedParam - pipeDelimited style without explode */}}

// StylePipeDelimitedParam serializes a value using pipeDelimited style without exploding.
// Pipe-delimited style is used for query parameters with array values.
// Arrays: paramName=a|b|c
// Note: Only valid for arrays; objects should use other styles.
func StylePipeDelimitedParam(paramName string, paramLocation ParamLocation, value interface{}) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf("%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]interface{}, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return stylePipeDelimitedSlice(paramName, paramLocation, sliceVal)
	default:
		// For primitives, fall back to form style
		return stylePipeDelimitedPrimitive(paramName, paramLocation, value)
	}
}

func stylePipeDelimitedPrimitive(paramName string, paramLocation ParamLocation, value interface{}) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func stylePipeDelimitedSlice(paramName string, paramLocation ParamLocation, values []interface{}) (string, error) {
	// Pipe-delimited without explode: paramName=a|b|c
	prefix := fmt.Sprintf("%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, "|"), nil
}
