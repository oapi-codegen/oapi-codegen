{{/* BindLabelExplodeParam - label style with explode */}}

// BindLabelExplodeParam binds a label-style parameter with explode to a destination.
// Label style values are prefixed with a dot.
// Primitives: .value -> "value"
// Arrays: .a.b.c -> []string{"a", "b", "c"}
// Objects: .key1=value1.key2=value2 -> struct{Key1, Key2}
func BindLabelExplodeParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Label style requires leading dot
	if value[0] != '.' {
		return fmt.Errorf("invalid format for label parameter '%s', should start with '.'", paramName)
	}

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(value[1:]))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		// Split on dot (skip first empty part)
		parts := strings.Split(value, ".")
		if parts[0] != "" {
			return fmt.Errorf("invalid format for label parameter '%s', should start with '.'", paramName)
		}
		return bindSplitPartsToDestinationStruct(paramName, parts[1:], true, dest)
	case reflect.Slice:
		// Split on dot (skip first empty part)
		parts := strings.Split(value, ".")
		if parts[0] != "" {
			return fmt.Errorf("invalid format for label parameter '%s', should start with '.'", paramName)
		}
		return bindSplitPartsToDestinationArray(parts[1:], dest)
	default:
		return BindStringToObject(value[1:], dest)
	}
}
