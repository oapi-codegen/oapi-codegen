{{/* BindMatrixExplodeParam - matrix style with explode */}}

// BindMatrixExplodeParam binds a matrix-style parameter with explode to a destination.
// Matrix style values are prefixed with semicolons.
// Primitives: ;paramName=value -> "value"
// Arrays: ;paramName=a;paramName=b;paramName=c -> []string{"a", "b", "c"}
// Objects: ;key1=value1;key2=value2 -> struct{Key1, Key2}
func BindMatrixExplodeParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Break up on semicolon
	parts := strings.Split(value, ";")
	// First part should be empty since we start with ;
	if parts[0] != "" {
		return fmt.Errorf("invalid format for matrix parameter '%s', should start with ';'", paramName)
	}
	parts = parts[1:]

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		// For primitives, should be ;paramName=value
		if len(parts) == 1 {
			kv := strings.SplitN(parts[0], "=", 2)
			if len(kv) == 2 && kv[0] == paramName {
				return tu.UnmarshalText([]byte(kv[1]))
			}
		}
		return fmt.Errorf("invalid format for matrix parameter '%s'", paramName)
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		// For objects, we have key1=value1, key2=value2
		return bindSplitPartsToDestinationStruct(paramName, parts, true, dest)
	case reflect.Slice:
		// For arrays, strip paramName= prefix from each part
		prefix := paramName + "="
		values := make([]string, len(parts))
		for i, part := range parts {
			values[i] = strings.TrimPrefix(part, prefix)
		}
		return bindSplitPartsToDestinationArray(values, dest)
	default:
		// Primitive: ;paramName=value
		if len(parts) == 1 {
			kv := strings.SplitN(parts[0], "=", 2)
			if len(kv) == 2 && kv[0] == paramName {
				return BindStringToObject(kv[1], dest)
			}
		}
		return fmt.Errorf("invalid format for matrix parameter '%s'", paramName)
	}
}
