{{/* Parameter styling and binding helper functions - included when any param function is used */}}

// ParamLocation indicates where a parameter is located in an HTTP request.
type ParamLocation int

const (
	ParamLocationUndefined ParamLocation = iota
	ParamLocationQuery
	ParamLocationPath
	ParamLocationHeader
	ParamLocationCookie
)

// Binder is an interface for types that can bind themselves from a string value.
type Binder interface {
	Bind(value string) error
}

// DateFormat is the format used for date (without time) parameters.
const DateFormat = "2006-01-02"

// Date represents a date (without time) for OpenAPI date format.
type Date struct {
	time.Time
}

// UnmarshalText implements encoding.TextUnmarshaler for Date.
func (d *Date) UnmarshalText(data []byte) error {
	t, err := time.Parse(DateFormat, string(data))
	if err != nil {
		return err
	}
	d.Time = t
	return nil
}

// MarshalText implements encoding.TextMarshaler for Date.
func (d Date) MarshalText() ([]byte, error) {
	return []byte(d.Format(DateFormat)), nil
}

// Format returns the date formatted according to layout.
func (d Date) Format(layout string) string {
	return d.Time.Format(layout)
}

// primitiveToString converts a primitive value to a string representation.
// It handles basic Go types, time.Time, types.Date, and types that implement
// json.Marshaler or fmt.Stringer.
func primitiveToString(value interface{}) (string, error) {
	// Check for known types first (time, date, uuid)
	if res, ok := marshalKnownTypes(value); ok {
		return res, nil
	}

	// Dereference pointers for optional values
	v := reflect.Indirect(reflect.ValueOf(value))
	t := v.Type()
	kind := t.Kind()

	switch kind {
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
		return strconv.FormatInt(v.Int(), 10), nil
	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
		return strconv.FormatUint(v.Uint(), 10), nil
	case reflect.Float64:
		return strconv.FormatFloat(v.Float(), 'f', -1, 64), nil
	case reflect.Float32:
		return strconv.FormatFloat(v.Float(), 'f', -1, 32), nil
	case reflect.Bool:
		if v.Bool() {
			return "true", nil
		}
		return "false", nil
	case reflect.String:
		return v.String(), nil
	case reflect.Struct:
		// Check if it's a UUID
		if u, ok := value.(uuid.UUID); ok {
			return u.String(), nil
		}
		// Check if it implements json.Marshaler
		if m, ok := value.(json.Marshaler); ok {
			buf, err := m.MarshalJSON()
			if err != nil {
				return "", fmt.Errorf("failed to marshal to JSON: %w", err)
			}
			e := json.NewDecoder(bytes.NewReader(buf))
			e.UseNumber()
			var i2 interface{}
			if err = e.Decode(&i2); err != nil {
				return "", fmt.Errorf("failed to decode JSON: %w", err)
			}
			return primitiveToString(i2)
		}
		fallthrough
	default:
		if s, ok := value.(fmt.Stringer); ok {
			return s.String(), nil
		}
		return "", fmt.Errorf("unsupported type %s", reflect.TypeOf(value).String())
	}
}

// marshalKnownTypes checks for special types (time.Time, Date, UUID) and marshals them.
func marshalKnownTypes(value interface{}) (string, bool) {
	v := reflect.Indirect(reflect.ValueOf(value))
	t := v.Type()

	if t.ConvertibleTo(reflect.TypeOf(time.Time{})) {
		tt := v.Convert(reflect.TypeOf(time.Time{}))
		timeVal := tt.Interface().(time.Time)
		return timeVal.Format(time.RFC3339Nano), true
	}

	if t.ConvertibleTo(reflect.TypeOf(Date{})) {
		d := v.Convert(reflect.TypeOf(Date{}))
		dateVal := d.Interface().(Date)
		return dateVal.Format(DateFormat), true
	}

	if t.ConvertibleTo(reflect.TypeOf(uuid.UUID{})) {
		u := v.Convert(reflect.TypeOf(uuid.UUID{}))
		uuidVal := u.Interface().(uuid.UUID)
		return uuidVal.String(), true
	}

	return "", false
}

// escapeParameterString escapes a parameter value based on its location.
// Query and path parameters need URL escaping; headers and cookies do not.
func escapeParameterString(value string, paramLocation ParamLocation) string {
	switch paramLocation {
	case ParamLocationQuery:
		return url.QueryEscape(value)
	case ParamLocationPath:
		return url.PathEscape(value)
	default:
		return value
	}
}

// unescapeParameterString unescapes a parameter value based on its location.
func unescapeParameterString(value string, paramLocation ParamLocation) (string, error) {
	switch paramLocation {
	case ParamLocationQuery, ParamLocationUndefined:
		return url.QueryUnescape(value)
	case ParamLocationPath:
		return url.PathUnescape(value)
	default:
		return value, nil
	}
}

// sortedKeys returns the keys of a map in sorted order.
func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// BindStringToObject binds a string value to a destination object.
// It handles primitives, encoding.TextUnmarshaler, and the Binder interface.
func BindStringToObject(src string, dst interface{}) error {
	// Check for TextUnmarshaler
	if tu, ok := dst.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(src))
	}

	// Check for Binder interface
	if b, ok := dst.(Binder); ok {
		return b.Bind(src)
	}

	v := reflect.ValueOf(dst)
	if v.Kind() != reflect.Ptr {
		return fmt.Errorf("dst must be a pointer, got %T", dst)
	}
	v = v.Elem()

	switch v.Kind() {
	case reflect.String:
		v.SetString(src)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		i, err := strconv.ParseInt(src, 10, 64)
		if err != nil {
			return fmt.Errorf("failed to parse int: %w", err)
		}
		v.SetInt(i)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		u, err := strconv.ParseUint(src, 10, 64)
		if err != nil {
			return fmt.Errorf("failed to parse uint: %w", err)
		}
		v.SetUint(u)
	case reflect.Float32, reflect.Float64:
		f, err := strconv.ParseFloat(src, 64)
		if err != nil {
			return fmt.Errorf("failed to parse float: %w", err)
		}
		v.SetFloat(f)
	case reflect.Bool:
		b, err := strconv.ParseBool(src)
		if err != nil {
			return fmt.Errorf("failed to parse bool: %w", err)
		}
		v.SetBool(b)
	default:
		// Try JSON unmarshal as a fallback
		return json.Unmarshal([]byte(src), dst)
	}
	return nil
}

// bindSplitPartsToDestinationArray binds a slice of string parts to a destination slice.
func bindSplitPartsToDestinationArray(parts []string, dest interface{}) error {
	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	newArray := reflect.MakeSlice(t, len(parts), len(parts))
	for i, p := range parts {
		err := BindStringToObject(p, newArray.Index(i).Addr().Interface())
		if err != nil {
			return fmt.Errorf("error setting array element: %w", err)
		}
	}
	v.Set(newArray)
	return nil
}

// bindSplitPartsToDestinationStruct binds string parts to a destination struct via JSON.
func bindSplitPartsToDestinationStruct(paramName string, parts []string, explode bool, dest interface{}) error {
	var fields []string
	if explode {
		fields = make([]string, len(parts))
		for i, property := range parts {
			propertyParts := strings.Split(property, "=")
			if len(propertyParts) != 2 {
				return fmt.Errorf("parameter '%s' has invalid exploded format", paramName)
			}
			fields[i] = "\"" + propertyParts[0] + "\":\"" + propertyParts[1] + "\""
		}
	} else {
		if len(parts)%2 != 0 {
			return fmt.Errorf("parameter '%s' has invalid format, property/values need to be pairs", paramName)
		}
		fields = make([]string, len(parts)/2)
		for i := 0; i < len(parts); i += 2 {
			key := parts[i]
			value := parts[i+1]
			fields[i/2] = "\"" + key + "\":\"" + value + "\""
		}
	}
	jsonParam := "{" + strings.Join(fields, ",") + "}"
	return json.Unmarshal([]byte(jsonParam), dest)
}
