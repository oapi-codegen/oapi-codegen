{{/* BindMatrixParam - matrix style without explode */}}

// BindMatrixParam binds a matrix-style parameter without explode to a destination.
// Matrix style values are prefixed with ;paramName=.
// Primitives: ;paramName=value -> "value"
// Arrays: ;paramName=a,b,c -> []string{"a", "b", "c"}
// Objects: ;paramName=key1,value1,key2,value2 -> struct{Key1, Key2}
func BindMatrixParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Matrix style requires ;paramName= prefix
	prefix := ";" + paramName + "="
	if !strings.HasPrefix(value, prefix) {
		return fmt.Errorf("expected parameter '%s' to start with %s", paramName, prefix)
	}

	// Strip the prefix
	stripped := strings.TrimPrefix(value, prefix)

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(stripped))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		parts := strings.Split(stripped, ",")
		return bindSplitPartsToDestinationStruct(paramName, parts, false, dest)
	case reflect.Slice:
		parts := strings.Split(stripped, ",")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(stripped, dest)
	}
}
