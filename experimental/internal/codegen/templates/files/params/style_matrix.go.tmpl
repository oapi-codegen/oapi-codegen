{{/* StyleMatrixParam - matrix style without explode */}}

// StyleMatrixParam serializes a value using matrix style (RFC 6570) without exploding.
// Matrix style prefixes values with ;paramName=.
// Primitives: ;paramName=value
// Arrays: ;paramName=a,b,c
// Objects: ;paramName=key1,value1,key2,value2
func StyleMatrixParam(paramName string, paramLocation ParamLocation, value interface{}) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(string(b), paramLocation)), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]interface{}, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleMatrixSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleMatrixStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleMatrixMap(paramName, paramLocation, value)
	default:
		return styleMatrixPrimitive(paramName, paramLocation, value)
	}
}

func styleMatrixPrimitive(paramName string, paramLocation ParamLocation, value interface{}) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(strVal, paramLocation)), nil
}

func styleMatrixSlice(paramName string, paramLocation ParamLocation, values []interface{}) (string, error) {
	// Matrix without explode: ;paramName=a,b,c
	prefix := fmt.Sprintf(";%s=", paramName)
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return prefix + strings.Join(parts, ","), nil
}

func styleMatrixStruct(paramName string, paramLocation ParamLocation, value interface{}) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return fmt.Sprintf(";%s=%s", paramName, escapeParameterString(timeVal, paramLocation)), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 interface{}
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleMatrixParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Matrix style without explode: ;paramName=key1,value1,key2,value2
	prefix := fmt.Sprintf(";%s=", paramName)
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return prefix + strings.Join(parts, ","), nil
}

func styleMatrixMap(paramName string, paramLocation ParamLocation, value interface{}) (string, error) {
	dict, ok := value.(map[string]interface{})
	if !ok {
		return "", errors.New("map not of type map[string]interface{}")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Matrix style without explode: ;paramName=key1,value1,key2,value2
	prefix := fmt.Sprintf(";%s=", paramName)
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return prefix + strings.Join(parts, ","), nil
}
