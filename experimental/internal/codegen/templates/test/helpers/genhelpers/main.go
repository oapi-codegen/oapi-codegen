// genhelpers generates Go files from helper and param templates.
// Usage: genhelpers -package <name> -output <dir> [templates...]
//
// The helpers template (ParamHelpersTemplate) is always included automatically.
//
// Example:
//
//	//go:generate genhelpers -package helpers -output . marshal_form style_simple bind_simple
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/oapi-codegen/oapi-codegen-exp/experimental/internal/codegen/templates"
	"golang.org/x/tools/imports"
)

func main() {
	packageName := flag.String("package", "", "Go package name for generated files")
	outputDir := flag.String("output", ".", "output directory for generated files")
	flag.Parse()

	if *packageName == "" {
		fmt.Fprintln(os.Stderr, "error: -package is required")
		os.Exit(1)
	}

	templateNames := flag.Args()
	if len(templateNames) == 0 {
		fmt.Fprintln(os.Stderr, "error: at least one template name required")
		fmt.Fprintln(os.Stderr, "available: marshal_form, style_simple, bind_simple, ...")
		os.Exit(1)
	}

	// Always generate the param helpers first (shared types/functions)
	if err := generateParamTemplate(*packageName, *outputDir, "helpers", templates.ParamHelpersTemplate); err != nil {
		fmt.Fprintf(os.Stderr, "error generating helpers: %v\n", err)
		os.Exit(1)
	}

	for _, name := range templateNames {
		if name == "marshal_form" {
			if err := generateHelperTemplate(*packageName, *outputDir, templates.MarshalFormHelperTemplate); err != nil {
				fmt.Fprintf(os.Stderr, "error generating %s: %v\n", name, err)
				os.Exit(1)
			}
		} else {
			pt, ok := templates.ParamTemplates[name]
			if !ok {
				fmt.Fprintf(os.Stderr, "error: unknown template %q\n", name)
				os.Exit(1)
			}
			if err := generateParamTemplate(*packageName, *outputDir, name, pt); err != nil {
				fmt.Fprintf(os.Stderr, "error generating %s: %v\n", name, err)
				os.Exit(1)
			}
		}
	}
}

func generateHelperTemplate(packageName, outputDir string, ht templates.HelperTemplate) error {
	return generateFile(packageName, outputDir, ht.Name, ht.Template, ht.Imports)
}

func generateParamTemplate(packageName, outputDir, name string, pt templates.ParamTemplate) error {
	return generateFile(packageName, outputDir, name, pt.Template, pt.Imports)
}

func generateFile(packageName, outputDir, name, tmplPath string, registryImports []templates.Import) error {
	// Read template content
	fullPath := "files/" + tmplPath
	tmplContent, err := templates.TemplateFS.ReadFile(fullPath)
	if err != nil {
		return fmt.Errorf("reading template %s: %w", fullPath, err)
	}

	// Parse and execute template (in case it has any directives)
	tmpl, err := template.New(name).Parse(string(tmplContent))
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	var body bytes.Buffer
	if err := tmpl.Execute(&body, nil); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	// Build the output file
	var out bytes.Buffer

	// Header
	fmt.Fprintf(&out, "// Code generated by genhelpers. DO NOT EDIT.\n\n")
	fmt.Fprintf(&out, "package %s\n", packageName)

	// Include all registry imports â€” goimports will prune unused ones
	if len(registryImports) > 0 {
		out.WriteString("\nimport (\n")
		for _, imp := range registryImports {
			if imp.Alias != "" {
				fmt.Fprintf(&out, "\t%s %q\n", imp.Alias, imp.Path)
			} else {
				fmt.Fprintf(&out, "\t%q\n", imp.Path)
			}
		}
		out.WriteString(")\n")
	}

	// Template body (skip the leading template comment if present)
	bodyStr := body.String()
	if strings.HasPrefix(bodyStr, "{{/*") {
		if idx := strings.Index(bodyStr, "*/}}"); idx != -1 {
			bodyStr = bodyStr[idx+4:]
		}
	}
	out.WriteString(bodyStr)

	// Run goimports to fix unused imports
	filename := name + ".gen.go"
	outputPath := filepath.Join(outputDir, filename)
	formatted, err := imports.Process(outputPath, out.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("running goimports on %s: %w", outputPath, err)
	}

	// Write output file
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("writing %s: %w", outputPath, err)
	}

	fmt.Printf("generated %s\n", outputPath)
	return nil
}
