// Code generated by genhelpers. DO NOT EDIT.

package helpers

import (
	"encoding/json"
	"fmt"
	"sort"
	"strconv"
	"strings"
)

// StyleDeepObjectParam serializes a value using deepObject style.
// DeepObject style is only valid for query parameters with object values and must be exploded.
// Objects: paramName[key1]=value1&paramName[key2]=value2
// Nested: paramName[outer][inner]=value
func StyleDeepObjectParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// deepObject always requires explode=true
	return MarshalDeepObject(value, paramName)
}

// MarshalDeepObject marshals an object to deepObject style query parameters.
func MarshalDeepObject(i any, paramName string) (string, error) {
	// Marshal to JSON first to handle all field annotations
	buf, err := json.Marshal(i)
	if err != nil {
		return "", fmt.Errorf("failed to marshal input to JSON: %w", err)
	}
	var i2 any
	err = json.Unmarshal(buf, &i2)
	if err != nil {
		return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
	}
	fields, err := marshalDeepObjectRecursive(i2, nil)
	if err != nil {
		return "", fmt.Errorf("error traversing JSON structure: %w", err)
	}

	// Prefix the param name to each subscripted field
	for idx := range fields {
		fields[idx] = paramName + fields[idx]
	}
	return strings.Join(fields, "&"), nil
}

func marshalDeepObjectRecursive(in any, path []string) ([]string, error) {
	var result []string

	switch t := in.(type) {
	case []any:
		// Arrays use numerical subscripts [0], [1], etc.
		for i, iface := range t {
			newPath := append(path, strconv.Itoa(i))
			fields, err := marshalDeepObjectRecursive(iface, newPath)
			if err != nil {
				return nil, fmt.Errorf("error traversing array: %w", err)
			}
			result = append(result, fields...)
		}
	case map[string]any:
		// Maps use key subscripts [key1], [key2], etc.
		keys := make([]string, 0, len(t))
		for k := range t {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, k := range keys {
			newPath := append(path, k)
			fields, err := marshalDeepObjectRecursive(t[k], newPath)
			if err != nil {
				return nil, fmt.Errorf("error traversing map: %w", err)
			}
			result = append(result, fields...)
		}
	default:
		// Concrete value: turn path into [a][b][c] format
		prefix := "[" + strings.Join(path, "][") + "]"
		result = []string{
			prefix + fmt.Sprintf("=%v", t),
		}
	}
	return result, nil
}
