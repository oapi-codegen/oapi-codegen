// gentypes generates Go type files from templates.
// Usage: gentypes -package <name> -output <dir> [types...]
//
// Example:
//
//	//go:generate gentypes -package types -output . Email Date UUID File
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/oapi-codegen/oapi-codegen/experimental/internal/codegen/templates"
)

func main() {
	packageName := flag.String("package", "", "Go package name for generated files")
	outputDir := flag.String("output", ".", "output directory for generated files")
	flag.Parse()

	if *packageName == "" {
		fmt.Fprintln(os.Stderr, "error: -package is required")
		os.Exit(1)
	}

	typeNames := flag.Args()
	if len(typeNames) == 0 {
		fmt.Fprintln(os.Stderr, "error: at least one type name required")
		fmt.Fprintln(os.Stderr, "available types: Email, Date, UUID, File")
		os.Exit(1)
	}

	for _, typeName := range typeNames {
		if err := generateType(*packageName, *outputDir, typeName); err != nil {
			fmt.Fprintf(os.Stderr, "error generating %s: %v\n", typeName, err)
			os.Exit(1)
		}
	}
}

func generateType(packageName, outputDir, typeName string) error {
	tt, ok := templates.TypeTemplates[typeName]
	if !ok {
		return fmt.Errorf("unknown type: %s", typeName)
	}

	// Read template content
	tmplPath := "files/" + tt.Template
	tmplContent, err := templates.TemplateFS.ReadFile(tmplPath)
	if err != nil {
		return fmt.Errorf("reading template %s: %w", tmplPath, err)
	}

	// Parse and execute template (in case it has any directives)
	tmpl, err := template.New(typeName).Parse(string(tmplContent))
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	var body bytes.Buffer
	if err := tmpl.Execute(&body, nil); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	// Build the output file
	var out bytes.Buffer

	// Package declaration
	fmt.Fprintf(&out, "// Code generated by gentypes. DO NOT EDIT.\n\n")
	fmt.Fprintf(&out, "package %s\n", packageName)

	// Imports
	if len(tt.Imports) > 0 {
		out.WriteString("\nimport (\n")
		for _, imp := range tt.Imports {
			if imp.Alias != "" {
				fmt.Fprintf(&out, "\t%s %q\n", imp.Alias, imp.Path)
			} else {
				fmt.Fprintf(&out, "\t%q\n", imp.Path)
			}
		}
		out.WriteString(")\n")
	}

	// Template body (skip the leading template comment if present)
	bodyStr := body.String()
	if strings.HasPrefix(bodyStr, "{{/*") {
		// Skip the comment line
		if idx := strings.Index(bodyStr, "*/}}"); idx != -1 {
			bodyStr = bodyStr[idx+4:]
		}
	}
	out.WriteString(bodyStr)

	// Write output file
	filename := strings.ToLower(typeName) + ".gen.go"
	outputPath := filepath.Join(outputDir, filename)
	if err := os.WriteFile(outputPath, out.Bytes(), 0644); err != nil {
		return fmt.Errorf("writing %s: %w", outputPath, err)
	}

	fmt.Printf("generated %s\n", outputPath)
	return nil
}
