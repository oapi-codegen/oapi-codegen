package codegen

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"text/template"

	"github.com/oapi-codegen/oapi-codegen/experimental/internal/codegen/templates"
	"github.com/pb33f/libopenapi"
	"github.com/stretchr/testify/require"
)

func TestPetstoreServerIntegration(t *testing.T) {
	// Read the petstore spec
	specPath := "../../examples/petstore-expanded/petstore-expanded.yaml"
	specData, err := os.ReadFile(specPath)
	require.NoError(t, err, "Failed to read petstore spec")

	// Parse the spec
	doc, err := libopenapi.NewDocument(specData)
	require.NoError(t, err, "Failed to parse petstore spec")

	// Create param tracker
	paramTracker := NewParamUsageTracker()

	// Gather operations
	ops, err := GatherOperations(doc, paramTracker)
	require.NoError(t, err, "Failed to gather operations")
	require.Len(t, ops, 4, "Expected 4 operations")

	// Log operations for debugging
	for _, op := range ops {
		t.Logf("Operation: %s %s -> %s", op.Method, op.Path, op.GoOperationID)
		t.Logf("  PathParams: %d, QueryParams: %d, HasParams: %v",
			len(op.PathParams), len(op.QueryParams), op.HasParams)
	}

	// Log param tracker usage
	t.Logf("Param styles used: %v", paramTracker.GetUsedStyleKeys())

	// Generate server code
	gen, err := NewServerGenerator()
	require.NoError(t, err, "Failed to create server generator")

	serverCode, err := gen.GenerateServer(ServerTypeStdHTTP, ops)
	require.NoError(t, err, "Failed to generate server code")
	require.NotEmpty(t, serverCode, "Generated server code should not be empty")

	// Generate param binding functions
	paramCode, err := generateParamFunctions(paramTracker)
	require.NoError(t, err, "Failed to generate param functions")

	// Verify key components are present
	require.Contains(t, serverCode, "type ServerInterface interface")
	require.Contains(t, serverCode, "FindPets")
	require.Contains(t, serverCode, "AddPet")
	require.Contains(t, serverCode, "DeletePet")
	require.Contains(t, serverCode, "FindPetByID")

	// Verify path parameters
	require.Contains(t, serverCode, `r.PathValue("id")`)

	// Verify query parameters
	require.Contains(t, serverCode, "FindPetsParams")
	require.Contains(t, serverCode, "Tags")
	require.Contains(t, serverCode, "Limit")

	// Write to the example directory for inspection
	outputPath := filepath.Join("../../examples/petstore-expanded/stdhttp/server", "server.gen.go")
	outputDir := filepath.Dir(outputPath)
	err = os.MkdirAll(outputDir, 0755)
	require.NoError(t, err, "Failed to create output directory")

	// Build imports from param tracker
	paramImports := paramTracker.GetRequiredImports()
	importLines := []string{
		`"fmt"`,
		`"net/http"`,
	}
	for _, imp := range paramImports {
		importLine := `"` + imp.Path + `"`
		// Check if already included
		found := false
		for _, existing := range importLines {
			if existing == importLine {
				found = true
				break
			}
		}
		if !found {
			importLines = append(importLines, importLine)
		}
	}

	// Add package header with imports
	var fullCode strings.Builder
	fullCode.WriteString("// Code generated by oapi-codegen. DO NOT EDIT.\n\n")
	fullCode.WriteString("package server\n\n")
	fullCode.WriteString("import (\n")
	for _, imp := range importLines {
		fullCode.WriteString("\t")
		fullCode.WriteString(imp)
		fullCode.WriteString("\n")
	}
	fullCode.WriteString(")\n\n")
	fullCode.WriteString(serverCode)
	fullCode.WriteString("\n")
	fullCode.WriteString(paramCode)

	err = os.WriteFile(outputPath, []byte(fullCode.String()), 0644)
	require.NoError(t, err, "Failed to write generated code")
	t.Logf("Wrote generated code to %s", outputPath)
}

// generateParamFunctions generates the parameter binding functions based on usage.
func generateParamFunctions(tracker *ParamUsageTracker) (string, error) {
	if !tracker.HasAnyUsage() {
		return "", nil
	}

	var buf bytes.Buffer

	// Get required templates
	requiredTemplates := tracker.GetRequiredTemplates()

	for _, tmplInfo := range requiredTemplates {
		content, err := templates.TemplateFS.ReadFile("files/" + tmplInfo.Template)
		if err != nil {
			return "", err
		}

		// Parse and execute the template
		tmpl, err := template.New(tmplInfo.Name).Parse(string(content))
		if err != nil {
			return "", err
		}

		err = tmpl.Execute(&buf, nil)
		if err != nil {
			return "", err
		}
		buf.WriteString("\n")
	}

	return buf.String(), nil
}
