package codegen

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"text/template"

	"github.com/oapi-codegen/oapi-codegen/experimental/internal/codegen/templates"
	"github.com/pb33f/libopenapi"
	"github.com/stretchr/testify/require"
)

func TestPetstoreServerIntegration(t *testing.T) {
	// Read the petstore spec
	specPath := "../../examples/petstore-expanded/petstore-expanded.yaml"
	specData, err := os.ReadFile(specPath)
	require.NoError(t, err, "Failed to read petstore spec")

	// Parse the spec
	doc, err := libopenapi.NewDocument(specData)
	require.NoError(t, err, "Failed to parse petstore spec")

	// Create param tracker
	paramTracker := NewParamUsageTracker()

	// Gather operations
	ops, err := GatherOperations(doc, paramTracker)
	require.NoError(t, err, "Failed to gather operations")
	require.Len(t, ops, 4, "Expected 4 operations")

	// Log operations for debugging
	for _, op := range ops {
		t.Logf("Operation: %s %s -> %s", op.Method, op.Path, op.GoOperationID)
		t.Logf("  PathParams: %d, QueryParams: %d, HasParams: %v",
			len(op.PathParams), len(op.QueryParams), op.HasParams)
	}

	// Log param tracker usage
	t.Logf("Param styles used: %v", paramTracker.GetUsedStyleKeys())

	// Generate server code
	gen, err := NewServerGenerator()
	require.NoError(t, err, "Failed to create server generator")

	serverCode, err := gen.GenerateServer(ServerTypeStdHTTP, ops)
	require.NoError(t, err, "Failed to generate server code")
	require.NotEmpty(t, serverCode, "Generated server code should not be empty")

	// Generate param binding functions
	paramCode, err := generateParamFunctions(paramTracker)
	require.NoError(t, err, "Failed to generate param functions")

	// Verify key components are present
	require.Contains(t, serverCode, "type ServerInterface interface")
	require.Contains(t, serverCode, "FindPets")
	require.Contains(t, serverCode, "AddPet")
	require.Contains(t, serverCode, "DeletePet")
	require.Contains(t, serverCode, "FindPetByID")

	// Verify path parameters
	require.Contains(t, serverCode, `r.PathValue("id")`)

	// Verify query parameters
	require.Contains(t, serverCode, "FindPetsParams")
	require.Contains(t, serverCode, "Tags")
	require.Contains(t, serverCode, "Limit")

	// Write to the example directory for inspection
	outputPath := filepath.Join("../../examples/petstore-expanded/stdhttp/server", "server.gen.go")
	outputDir := filepath.Dir(outputPath)
	err = os.MkdirAll(outputDir, 0755)
	require.NoError(t, err, "Failed to create output directory")

	// Build imports from param tracker
	paramImports := paramTracker.GetRequiredImports()
	importLines := []string{
		`"fmt"`,
		`"net/http"`,
	}
	for _, imp := range paramImports {
		importLine := `"` + imp.Path + `"`
		// Check if already included
		found := false
		for _, existing := range importLines {
			if existing == importLine {
				found = true
				break
			}
		}
		if !found {
			importLines = append(importLines, importLine)
		}
	}

	// Add package header with imports
	var fullCode strings.Builder
	fullCode.WriteString("// Code generated by oapi-codegen. DO NOT EDIT.\n\n")
	fullCode.WriteString("package server\n\n")
	fullCode.WriteString("import (\n")
	for _, imp := range importLines {
		fullCode.WriteString("\t")
		fullCode.WriteString(imp)
		fullCode.WriteString("\n")
	}
	fullCode.WriteString(")\n\n")
	fullCode.WriteString(serverCode)
	fullCode.WriteString("\n")
	fullCode.WriteString(paramCode)

	err = os.WriteFile(outputPath, []byte(fullCode.String()), 0644)
	require.NoError(t, err, "Failed to write generated code")
	t.Logf("Wrote generated code to %s", outputPath)
}

// generateParamFunctions generates the parameter binding functions based on usage.
func generateParamFunctions(tracker *ParamUsageTracker) (string, error) {
	if !tracker.HasAnyUsage() {
		return "", nil
	}

	var buf bytes.Buffer

	// Get required templates
	requiredTemplates := tracker.GetRequiredTemplates()

	for _, tmplInfo := range requiredTemplates {
		content, err := templates.TemplateFS.ReadFile("files/" + tmplInfo.Template)
		if err != nil {
			return "", err
		}

		// Parse and execute the template
		tmpl, err := template.New(tmplInfo.Name).Parse(string(content))
		if err != nil {
			return "", err
		}

		err = tmpl.Execute(&buf, nil)
		if err != nil {
			return "", err
		}
		buf.WriteString("\n")
	}

	return buf.String(), nil
}

func TestPetstoreClientIntegration(t *testing.T) {
	// Read the petstore spec
	specPath := "../../examples/petstore-expanded/petstore-expanded.yaml"
	specData, err := os.ReadFile(specPath)
	require.NoError(t, err, "Failed to read petstore spec")

	// Parse the spec
	doc, err := libopenapi.NewDocument(specData)
	require.NoError(t, err, "Failed to parse petstore spec")

	// Gather schemas for type resolution
	contentTypeMatcher := NewContentTypeMatcher(DefaultContentTypes())
	schemas, err := GatherSchemas(doc, contentTypeMatcher)
	require.NoError(t, err, "Failed to gather schemas")

	// Compute names for schemas
	converter := NewNameConverter(NameMangling{}, NameSubstitutions{})
	contentTypeNamer := NewContentTypeShortNamer(DefaultContentTypeShortNames())
	ComputeSchemaNames(schemas, converter, contentTypeNamer)

	// Build schema index
	schemaIndex := make(map[string]*SchemaDescriptor)
	for _, s := range schemas {
		schemaIndex[s.Path.String()] = s
	}

	// Create param tracker
	paramTracker := NewParamUsageTracker()

	// Gather operations
	ops, err := GatherOperations(doc, paramTracker)
	require.NoError(t, err, "Failed to gather operations")
	require.Len(t, ops, 4, "Expected 4 operations")

	// Generate client code
	clientGen, err := NewClientGenerator(schemaIndex, true)
	require.NoError(t, err, "Failed to create client generator")

	clientCode, err := clientGen.GenerateClient(ops)
	require.NoError(t, err, "Failed to generate client code")
	require.NotEmpty(t, clientCode, "Generated client code should not be empty")

	// Generate param styling functions
	paramCode, err := generateParamFunctions(paramTracker)
	require.NoError(t, err, "Failed to generate param functions")

	// Verify key components are present
	require.Contains(t, clientCode, "type Client struct")
	require.Contains(t, clientCode, "NewClient")
	require.Contains(t, clientCode, "type ClientInterface interface")
	require.Contains(t, clientCode, "type SimpleClient struct")
	require.Contains(t, clientCode, "NewSimpleClient")

	// Verify simplified client methods that return types directly
	require.Contains(t, clientCode, "type ClientHttpError[E any] struct")
	require.Contains(t, clientCode, "func (c *SimpleClient) FindPets")
	require.Contains(t, clientCode, "([]Pet, error)")
	require.Contains(t, clientCode, "&ClientHttpError[Error]")

	// Write to the example directory for inspection
	outputPath := filepath.Join("../../examples/petstore-expanded/client", "client.gen.go")
	outputDir := filepath.Dir(outputPath)
	err = os.MkdirAll(outputDir, 0755)
	require.NoError(t, err, "Failed to create output directory")

	// Build imports
	importLines := []string{
		`"bytes"`,
		`"context"`,
		`"encoding/json"`,
		`"fmt"`,
		`"io"`,
		`"net/http"`,
		`"net/url"`,
		`"strings"`,
	}
	paramImports := paramTracker.GetRequiredImports()
	for _, imp := range paramImports {
		importLine := `"` + imp.Path + `"`
		found := false
		for _, existing := range importLines {
			if existing == importLine {
				found = true
				break
			}
		}
		if !found {
			importLines = append(importLines, importLine)
		}
	}

	// Add package header with imports
	var fullCode strings.Builder
	fullCode.WriteString("// Code generated by oapi-codegen. DO NOT EDIT.\n\n")
	fullCode.WriteString("package client\n\n")
	fullCode.WriteString("import (\n")
	for _, imp := range importLines {
		fullCode.WriteString("\t")
		fullCode.WriteString(imp)
		fullCode.WriteString("\n")
	}
	fullCode.WriteString(")\n\n")

	// Add type definitions from petstore
	fullCode.WriteString("// Types from petstore schema\n")
	fullCode.WriteString("type Pet struct {\n\tID   int64   `json:\"id\"`\n\tName string  `json:\"name\"`\n\tTag  *string `json:\"tag,omitempty\"`\n}\n\n")
	fullCode.WriteString("type NewPet struct {\n\tName string  `json:\"name\"`\n\tTag  *string `json:\"tag,omitempty\"`\n}\n\n")
	fullCode.WriteString("type Error struct {\n\tCode    int32  `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\n")
	fullCode.WriteString("type addPetJSONRequestBody = NewPet\n\n")

	fullCode.WriteString(clientCode)
	fullCode.WriteString("\n")
	fullCode.WriteString(paramCode)

	err = os.WriteFile(outputPath, []byte(fullCode.String()), 0644)
	require.NoError(t, err, "Failed to write generated code")
	t.Logf("Wrote generated client code to %s", outputPath)
}
