// Code generated by oapi-codegen; DO NOT EDIT.

package output

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"strings"
	"sync"
)

// Base64-encoded, gzip-compressed OpenAPI spec.
var openAPISpecJSON = []string{
	"H4sIAAAAAAAC/5SSwe7aMAzG730Kq5vEiabALbcdOUyaBi+QtYZ6apwsMWho2rtPCWmBAYd/Ts3nz/7y",
	"s+o8svGkod40bbOqK+KD0xXAGUMkxxpWTdu0FYCQjKhhj1Fgh+GMoQIYqUOOmBoA2FjU8HW7r2KuxyQv",
	"4RRGDYOI10qVOMEoTY/orfGNocobGbJbRbJ+xG+BLAmdUf3xJhj79xqQv1HK5HSWJTRXigZAnBQZZiHg",
	"rxMF7DVIOOEsR7kkpGvmTe0GtEbPdwC5eNRALHjM1NM5uGCN5MpmnfUjytToPAYj5Hjb66TvHsmK6xnp",
	"HdQLrLdg79BewU14UQLx8aHwzJcSo3cc8e69i3XbLu5Hfg540FB/Up2z3jGyRDX3qesivpd7Xd1MacZ/",
	"8x/NU0iPsQvkJf+gXwrl3Arux0/spHg7x4Ist/cJ/hblR0OsP7KYfwEAAP//YI1KuyoDAAA=",
}

// decodeOpenAPISpec decodes and decompresses the embedded spec.
func decodeOpenAPISpec() ([]byte, error) {
	joined := strings.Join(openAPISpecJSON, "")
	raw, err := base64.StdEncoding.DecodeString(joined)
	if err != nil {
		return nil, fmt.Errorf("decoding base64: %w", err)
	}
	r, err := gzip.NewReader(bytes.NewReader(raw))
	if err != nil {
		return nil, fmt.Errorf("creating gzip reader: %w", err)
	}
	defer r.Close()
	var out bytes.Buffer
	if _, err := out.ReadFrom(r); err != nil {
		return nil, fmt.Errorf("decompressing: %w", err)
	}
	return out.Bytes(), nil
}

// decodeOpenAPISpecCached returns a closure that caches the decoded spec.
func decodeOpenAPISpecCached() func() ([]byte, error) {
	var cached []byte
	var cachedErr error
	var once sync.Once
	return func() ([]byte, error) {
		once.Do(func() {
			cached, cachedErr = decodeOpenAPISpec()
		})
		return cached, cachedErr
	}
}

var openAPISpec = decodeOpenAPISpecCached()

// GetOpenAPISpecJSON returns the raw OpenAPI spec as JSON bytes.
func GetOpenAPISpecJSON() ([]byte, error) {
	return openAPISpec()
}
