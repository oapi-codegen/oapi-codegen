// Code generated by oapi-codegen; DO NOT EDIT.

package output

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"sync"
)

// #/components/schemas/ProblemDetails
type ProblemDetails struct {
	Type                 *string        `json:"type,omitempty" form:"type,omitempty"`
	Title                *string        `json:"title,omitempty" form:"title,omitempty"`
	Status               *int32         `json:"status,omitempty" form:"status,omitempty"`
	Detail               *string        `json:"detail,omitempty" form:"detail,omitempty"`
	Instance             *string        `json:"instance,omitempty" form:"instance,omitempty"`
	AdditionalProperties map[string]any `json:"-"`
}

func (s ProblemDetails) MarshalJSON() ([]byte, error) {
	result := make(map[string]any)

	if s.Type != nil {
		result["type"] = s.Type
	}
	if s.Title != nil {
		result["title"] = s.Title
	}
	if s.Status != nil {
		result["status"] = s.Status
	}
	if s.Detail != nil {
		result["detail"] = s.Detail
	}
	if s.Instance != nil {
		result["instance"] = s.Instance
	}

	// Add additional properties
	for k, v := range s.AdditionalProperties {
		result[k] = v
	}

	return json.Marshal(result)
}

func (s *ProblemDetails) UnmarshalJSON(data []byte) error {
	// Known fields
	knownFields := map[string]bool{
		"type":     true,
		"title":    true,
		"status":   true,
		"detail":   true,
		"instance": true,
	}

	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	if v, ok := raw["type"]; ok {
		var val string
		if err := json.Unmarshal(v, &val); err != nil {
			return err
		}
		s.Type = &val
	}
	if v, ok := raw["title"]; ok {
		var val string
		if err := json.Unmarshal(v, &val); err != nil {
			return err
		}
		s.Title = &val
	}
	if v, ok := raw["status"]; ok {
		var val int32
		if err := json.Unmarshal(v, &val); err != nil {
			return err
		}
		s.Status = &val
	}
	if v, ok := raw["detail"]; ok {
		var val string
		if err := json.Unmarshal(v, &val); err != nil {
			return err
		}
		s.Detail = &val
	}
	if v, ok := raw["instance"]; ok {
		var val string
		if err := json.Unmarshal(v, &val); err != nil {
			return err
		}
		s.Instance = &val
	}

	// Collect additional properties
	s.AdditionalProperties = make(map[string]any)
	for k, v := range raw {
		if !knownFields[k] {
			var val any
			if err := json.Unmarshal(v, &val); err != nil {
				return err
			}
			s.AdditionalProperties[k] = val
		}
	}

	return nil
}

// ApplyDefaults sets default values for fields that are nil.
func (s *ProblemDetails) ApplyDefaults() {
	if s.Type == nil {
		v := "about:blank"
		s.Type = &v
	}
}

// Base64-encoded, gzip-compressed OpenAPI spec.
var openAPISpecJSON = []string{
	"H4sIAAAAAAAC/8RW34/UNhB+z18x0lZaUG+T5e7ah1AhUWgLEtee4BC8eu1JMuCMU3u83PLXV86P3c3d",
	"Uqj6wL3k1hl/M9/nmc9ZrVbZAp65buepbgTO1+cX8Mx5F87So8vhqbXwOr0L8BoD+i2aPFtkC3jaKd0g",
	"nOdreEUaOaB5DNIgdM4LOQZibaNBA5V3bbaARqQLZVHUJE3c5Nq1xWdlFRtXdN5tLLYFUICrlzdgR8Bs",
	"kbkOWXVUwkW+zi8y4sqVGcAWfSDHJTzK1/k6AxASiyXcYJAMwGDQnjrpQ66925LBAEprDAHEgTTEdchg",
	"ypQgAVi1WE7ERlKJYP8yelv2HMqi+PTpU463qu0s9jzev3+fZb04PiSo1SE6nAhXHfWQd6s0UffKIW/J",
	"O26RJcs6JU0PWmwfFYJBhlprHP8BCLFtld+V8AcKkIyrHkPnOGCYwgCW5+v18vDzTgFvYi9PFe1+71Go",
	"dizIcrwbQPBWis4q4vk6gOw6LCGIJ64P+S/v5P/BY1XCclFo13aOkSUU+7qLKwr6cr3+zXvnl8cgl/8Z",
	"5HIEyQ4xCeKORscJpwwziX5VBjz+HYcmOymL6jpLWqX4qa1//BDcTKCgG2zVXLJTLIa4UFwPOM9RFNmw",
	"PKr18su1/ukEKhfZfM9KswliVHgBv6PoZjSF/YCkIQ8ueo35aAn9nEy2MEDkO9XaEUWxgWCTLdkdtM5Q",
	"RcmXhpfXygu46lsM53FvN+Oo99vnDCbmQzu7zQfU08krYyhpp+y1dx16IQwliI/T1HSH5Ww2FtlXxgSg",
	"cr5VUkL09KVpfbKaHcpTBrUJzkZBePv6JUijBMggS5ImDMY8UOuT5gDvGmQw6LFCj6zRnM0QSeDNi7/e",
	"vnqe9iX/hCa2ilcelVEbi2Ccjsmi+g5KJd9LMsN7gHmdn0EMxDW8uLl69TCfcatUtFLCUm1clHJjFX9c",
	"HgWM/lnCcjrWqVPG46XDqWrHQbwiltWWnO0LPGANN8XXD+Ff5YbQOC9nk/emdrsv8TtPIphuQkCuLYWm",
	"b9xJwRli0g+5Jkb0AR7EEJW1O2AnECJJmhjngR2DoG6YtLIQRH3ExlmTtqj9pA9/aad1Wln6jObh44OA",
	"b9BvSSO8ZbVVZGeVBFESw31xiAVr9CdalFguzr9RtZsG4cXNzfWYBrQzCDUyepUIbna9hs5TTQzDdTr2",
	"FQVwWkffN+oMcy78cUu1xNTGtoRH6/Xxsrodln+eLeOttjHQFq+m90ejPGvAn9YX2YFtson/3Uz9ZO37",
	"AvC2s4qHuQodaqpIj18txzqM3GdYJ3TYF/7MMePwhSEOjBK1UQFBqEUDLsp+D3EQxfr7OdWe9D2ypwgC",
	"vBRo1Q6c7x+p83eE1kAVvTToIX01pjr7z9JqZnrTpfFLcXQTPMn+CQAA//++yR1/GQsAAA==",
}

// decodeOpenAPISpec decodes and decompresses the embedded spec.
func decodeOpenAPISpec() ([]byte, error) {
	joined := strings.Join(openAPISpecJSON, "")
	raw, err := base64.StdEncoding.DecodeString(joined)
	if err != nil {
		return nil, fmt.Errorf("decoding base64: %w", err)
	}
	r, err := gzip.NewReader(bytes.NewReader(raw))
	if err != nil {
		return nil, fmt.Errorf("creating gzip reader: %w", err)
	}
	defer r.Close()
	var out bytes.Buffer
	if _, err := out.ReadFrom(r); err != nil {
		return nil, fmt.Errorf("decompressing: %w", err)
	}
	return out.Bytes(), nil
}

// decodeOpenAPISpecCached returns a closure that caches the decoded spec.
func decodeOpenAPISpecCached() func() ([]byte, error) {
	var cached []byte
	var cachedErr error
	var once sync.Once
	return func() ([]byte, error) {
		once.Do(func() {
			cached, cachedErr = decodeOpenAPISpec()
		})
		return cached, cachedErr
	}
}

var openAPISpec = decodeOpenAPISpecCached()

// GetOpenAPISpecJSON returns the raw OpenAPI spec as JSON bytes.
func GetOpenAPISpecJSON() ([]byte, error) {
	return openAPISpec()
}
