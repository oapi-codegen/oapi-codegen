// Code generated by oapi-codegen; DO NOT EDIT.

package output

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"sync"
)

// #/components/schemas/test
type Test struct {
	TestAnyOf0 *TestAnyOf0
	TestAnyOf1 *TestAnyOf1
}

func (u Test) MarshalJSON() ([]byte, error) {
	result := make(map[string]any)

	if u.TestAnyOf0 != nil {
		data, err := json.Marshal(u.TestAnyOf0)
		if err != nil {
			return nil, err
		}
		var m map[string]any
		if err := json.Unmarshal(data, &m); err == nil {
			for k, v := range m {
				result[k] = v
			}
		}
	}
	if u.TestAnyOf1 != nil {
		data, err := json.Marshal(u.TestAnyOf1)
		if err != nil {
			return nil, err
		}
		var m map[string]any
		if err := json.Unmarshal(data, &m); err == nil {
			for k, v := range m {
				result[k] = v
			}
		}
	}

	return json.Marshal(result)
}

func (u *Test) UnmarshalJSON(data []byte) error {
	var v0 TestAnyOf0
	if err := json.Unmarshal(data, &v0); err == nil {
		u.TestAnyOf0 = &v0
	}

	var v1 TestAnyOf1
	if err := json.Unmarshal(data, &v1); err == nil {
		u.TestAnyOf1 = &v1
	}

	return nil
}

// ApplyDefaults sets default values for fields that are nil.
func (u *Test) ApplyDefaults() {
	if u.TestAnyOf0 != nil {
		u.TestAnyOf0.ApplyDefaults()
	}
	if u.TestAnyOf1 != nil {
		u.TestAnyOf1.ApplyDefaults()
	}
}

// #/components/schemas/test/anyOf/0
type TestAnyOf0 struct {
	Item1 string `json:"item1" form:"item1"`
	Item2 string `json:"item2" form:"item2"`
}

// ApplyDefaults sets default values for fields that are nil.
func (s *TestAnyOf0) ApplyDefaults() {
}

// #/components/schemas/test/anyOf/1
type TestAnyOf1 struct {
	Item2 *string `json:"item2,omitempty" form:"item2,omitempty"`
	Item3 *string `json:"item3,omitempty" form:"item3,omitempty"`
}

// ApplyDefaults sets default values for fields that are nil.
func (s *TestAnyOf1) ApplyDefaults() {
}

// #/components/schemas/test2
type Test2 struct {
	Int0    *int
	String1 *string
}

func (u Test2) MarshalJSON() ([]byte, error) {
	var count int
	var data []byte
	var err error

	if u.Int0 != nil {
		count++
		data, err = json.Marshal(u.Int0)
		if err != nil {
			return nil, err
		}
	}
	if u.String1 != nil {
		count++
		data, err = json.Marshal(u.String1)
		if err != nil {
			return nil, err
		}
	}

	if count != 1 {
		return nil, fmt.Errorf("Test2: exactly one member must be set, got %d", count)
	}

	return data, nil
}

func (u *Test2) UnmarshalJSON(data []byte) error {
	var successCount int

	var v0 int
	if err := json.Unmarshal(data, &v0); err == nil {
		u.Int0 = &v0
		successCount++
	}

	var v1 string
	if err := json.Unmarshal(data, &v1); err == nil {
		u.String1 = &v1
		successCount++
	}

	if successCount != 1 {
		return fmt.Errorf("Test2: expected exactly one type to match, got %d", successCount)
	}

	return nil
}

// ApplyDefaults sets default values for fields that are nil.
func (u *Test2) ApplyDefaults() {
}

// #/paths//test/get/parameters/1/schema
type GetTestParameter = []Test2

// Base64-encoded, gzip-compressed OpenAPI spec.
var openAPISpecJSON = []string{
	"H4sIAAAAAAAC/5SSTVLDMAyF9znFm8JMV/1Ld94xHIAzmFRtBI3tSioz4fRM0rRJIVC6cz496T0rjomC",
	"T+wwWc+X8+Uk47CNLgM+SJRjcFg1PAOMbU8OT6F+2SJ58RUZSQZsSAvhZK36uaTiXfs6lIT9nj8JpddT",
	"d5a8ldqYLIzUmgOwo+6AvlnPZIbgK3Jo5B0CODgcjiT1hWhRUuXd5Rt4FNo6TB8WRaxSDBRMFyeVtt7T",
	"EYP8LgerEzl4EV8PKBtVOpTdjpJPs77StHbF05R+UYBvltgPn3UZ4usbFTbwFDocWWhznWPWhluNsHzA",
	"ksREYkzfbtH2XqPzDtSEw+6HOv+X+tdL/BUkvyvI+qa6/Q1nVQw0tmUORrv23V/zbsxXAAAA//8J8F+B",
	"UAMAAA==",
}

// decodeOpenAPISpec decodes and decompresses the embedded spec.
func decodeOpenAPISpec() ([]byte, error) {
	joined := strings.Join(openAPISpecJSON, "")
	raw, err := base64.StdEncoding.DecodeString(joined)
	if err != nil {
		return nil, fmt.Errorf("decoding base64: %w", err)
	}
	r, err := gzip.NewReader(bytes.NewReader(raw))
	if err != nil {
		return nil, fmt.Errorf("creating gzip reader: %w", err)
	}
	defer r.Close()
	var out bytes.Buffer
	if _, err := out.ReadFrom(r); err != nil {
		return nil, fmt.Errorf("decompressing: %w", err)
	}
	return out.Bytes(), nil
}

// decodeOpenAPISpecCached returns a closure that caches the decoded spec.
func decodeOpenAPISpecCached() func() ([]byte, error) {
	var cached []byte
	var cachedErr error
	var once sync.Once
	return func() ([]byte, error) {
		once.Do(func() {
			cached, cachedErr = decodeOpenAPISpec()
		})
		return cached, cachedErr
	}
}

var openAPISpec = decodeOpenAPISpecCached()

// GetOpenAPISpecJSON returns the raw OpenAPI spec as JSON bytes.
func GetOpenAPISpecJSON() ([]byte, error) {
	return openAPISpec()
}
