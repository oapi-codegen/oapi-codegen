// Code generated by oapi-codegen; DO NOT EDIT.

package output

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
	"sync"
	"time"
)

// #/components/schemas/Pet
type Pet struct {
	Born   *any  `json:"born,omitempty" form:"born,omitempty"`
	BornAt *Date `json:"born_at,omitempty" form:"born_at,omitempty"`
}

// ApplyDefaults sets default values for fields that are nil.
func (s *Pet) ApplyDefaults() {
}

// Base64-encoded, gzip-compressed OpenAPI spec.
var openAPISpecJSON = []string{
	"H4sIAAAAAAAC/2SSz86bMBDE7zzFiPTamLaKovhWqZfc8gaVYzbgCryWd9M/b18Z+ET8fZzY0c74N+AD",
	"riJPwul8sfg+BSfUQ/8lEvwJOqJ3Snhwnp02B4yqSawxQ9DxeT96ng27FD577mmgWA+hBIs5nS8NJ4ou",
	"BYv227E7dm0T4oNtA/ymLIGjxZeiN4AGncjuUFASbZLTUcq+SZPzNPLUUy4zMJCuLwAnyk4Dx2tvi37b",
	"d7eNTJI4CsmbBfjadfsA9CQ+h6QLVPoQUB7PUSnqqwtQ+qsFLsRaB8SPNLv3KpaPbCGaQxwaz3PiSFEX",
	"stWyQd72gquF77/I6yalXFpreK1051xRfMr0sGgPZj/FbEeY7Zf/cEptFfDTVQ0r2l1eb4Zdrskiv+TV",
	"1JW1sv0PAAD//3OxuKeDAgAA",
}

// decodeOpenAPISpec decodes and decompresses the embedded spec.
func decodeOpenAPISpec() ([]byte, error) {
	joined := strings.Join(openAPISpecJSON, "")
	raw, err := base64.StdEncoding.DecodeString(joined)
	if err != nil {
		return nil, fmt.Errorf("decoding base64: %w", err)
	}
	r, err := gzip.NewReader(bytes.NewReader(raw))
	if err != nil {
		return nil, fmt.Errorf("creating gzip reader: %w", err)
	}
	defer r.Close()
	var out bytes.Buffer
	if _, err := out.ReadFrom(r); err != nil {
		return nil, fmt.Errorf("decompressing: %w", err)
	}
	return out.Bytes(), nil
}

// decodeOpenAPISpecCached returns a closure that caches the decoded spec.
func decodeOpenAPISpecCached() func() ([]byte, error) {
	var cached []byte
	var cachedErr error
	var once sync.Once
	return func() ([]byte, error) {
		once.Do(func() {
			cached, cachedErr = decodeOpenAPISpec()
		})
		return cached, cachedErr
	}
}

var openAPISpec = decodeOpenAPISpecCached()

// GetOpenAPISpecJSON returns the raw OpenAPI spec as JSON bytes.
func GetOpenAPISpecJSON() ([]byte, error) {
	return openAPISpec()
}

const DateFormat = "2006-01-02"

type Date struct {
	time.Time
}

func (d Date) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Format(DateFormat))
}

func (d *Date) UnmarshalJSON(data []byte) error {
	var dateStr string
	err := json.Unmarshal(data, &dateStr)
	if err != nil {
		return err
	}
	parsed, err := time.Parse(DateFormat, dateStr)
	if err != nil {
		return err
	}
	d.Time = parsed
	return nil
}

func (d Date) String() string {
	return d.Format(DateFormat)
}

func (d *Date) UnmarshalText(data []byte) error {
	parsed, err := time.Parse(DateFormat, string(data))
	if err != nil {
		return err
	}
	d.Time = parsed
	return nil
}
