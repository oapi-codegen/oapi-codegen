// Code generated by oapi-codegen; DO NOT EDIT.

package doorbadge

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
)

// #/components/schemas/WebhookRegistration
type WebhookRegistration struct {
	URL string `json:"url" form:"url"` // URL to receive webhook events
}

// ApplyDefaults sets default values for fields that are nil.
func (s *WebhookRegistration) ApplyDefaults() {
}

// #/components/schemas/WebhookRegistrationResponse
type WebhookRegistrationResponse struct {
	ID UUID `json:"id" form:"id"` // Unique identifier for this webhook registration
}

// ApplyDefaults sets default values for fields that are nil.
func (s *WebhookRegistrationResponse) ApplyDefaults() {
}

// #/components/schemas/Person
type Person struct {
	Name string `json:"name" form:"name"` // Name of the person who badged in or out
}

// ApplyDefaults sets default values for fields that are nil.
func (s *Person) ApplyDefaults() {
}

// #/components/schemas/Error
type Error struct {
	Code    int32  `json:"code" form:"code"`       // Error code
	Message string `json:"message" form:"message"` // Error message
}

// ApplyDefaults sets default values for fields that are nil.
func (s *Error) ApplyDefaults() {
}

// #/paths//api/webhook/{kind}/post/parameters/0/schema
type PostAPIWebhookKindParameter string

const (
	PostAPIWebhookKindParameter_enterEvent PostAPIWebhookKindParameter = "enterEvent"
	PostAPIWebhookKindParameter_exitEvent  PostAPIWebhookKindParameter = "exitEvent"
)

type UUID = uuid.UUID

// Base64-encoded, gzip-compressed OpenAPI spec.
var openAPISpecJSON = []string{
	"H4sIAAAAAAAC/9RWTY/bNhC961cM0gI+RfLu9qTbJuvDAkGycFL0TItjaxKJZIaUvEbb/16Q1GdX3l0D",
	"RZv6ZEnDmfceh4+jDSphKIc3N+lVun6TkNrrPAFokS1plcNVuk7XCYAjV2EOd1ozvBPygLBFIZETAIm2",
	"YDIuxP+RAADcgvSBuxDIIRAscksFgiuFA4m1VtaxcGjhk0F1+3APN+kVHHFXav3NpiHP+4pQOQuMB7IO",
	"GfaaAZVD3rSoHAglAR/JxadhLXwpMdQL+ABYKKnr6gQHVBhrRmjYhvQ+jdKO9oQWRFUN9VBC5f8o5ICo",
	"ogKVxTxkVaLGHG6NKEqE66ASQMNVDqVzxuZZdjweUxG+p5oPWbfaZh/u328+ft68vU7XaenqKjHCldZn",
	"zYShrOOR/f6NlPwzFjPauvgPwDZ1LfiUw7aXRfTcu4iFLfG/Pt6OC4KirkQ4UIsqCgK+7lREOFJVwcOn",
	"z1+GVE6HVYZ1SxIl/Lr9AMcSFfpw0SfS+7jdPiHoomi421gAbfxOkFb3ciTy24yFESxq9Hjzoe7bTnaf",
	"cXgJQCoHL+LkFeP3hhhlDo4bnHywRYm1yCdvANzJYA7WManD7AOqpp6HegxjCz791LdjMsJA695peRrz",
	"nMFWaOVQuWk9YUxFRRAq+2q1mmNZogLwM+M+h9VPWaFro5Vv8SxG2qxTOAoeN2A1ILVG+/4c862u11er",
	"afpZY3W5JqdlErnA5SU25/hczGjbMVklI+69aCp3lkqj8NFg4VACMmv+L4hsfOHVExOg3gIkVujwiQnc",
	"Ib/KBrZY69b7GxjGlnRjq9PU6HpD2J2AnIX7u8WTOlZ7/Vmlf+Wk7jXXwuXQNEO95Y7+5eWOlrjQ0/+j",
	"HupvQr949KpnbpIHZKtVjEUZrH3XUCVHkWddsPm7//1gLhfpPG9s6/NtEMcJxgKpDQ0wmPorJHwk9xoF",
	"f+xr4p8VcCzgV3Q14uIF9+6zxpOud1+xmKoUBJl4TMNV70HsJXY0xennseRF9xi8g+kcJT/gON1zGtwy",
	"TpDJOS79TXQhp8HBliiRvIRRM3PfOSVF3xsEkqjC7MvdMEh2oMcTLpFk7IwL+fh74BlG4Zp4mdMM/EdR",
	"Y5wvEUw8esdSx7leAinQDLpxEXSwxQsxF1ri5LFGa8XhORZ+wVMWpBwekBe2hpS7uT57gjziOYYOwaVC",
	"xUw9/L8CAAD//+XREy3yDQAA",
}

// decodeOpenAPISpec decodes and decompresses the embedded spec.
func decodeOpenAPISpec() ([]byte, error) {
	joined := strings.Join(openAPISpecJSON, "")
	raw, err := base64.StdEncoding.DecodeString(joined)
	if err != nil {
		return nil, fmt.Errorf("decoding base64: %w", err)
	}
	r, err := gzip.NewReader(bytes.NewReader(raw))
	if err != nil {
		return nil, fmt.Errorf("creating gzip reader: %w", err)
	}
	defer r.Close()
	var out bytes.Buffer
	if _, err := out.ReadFrom(r); err != nil {
		return nil, fmt.Errorf("decompressing: %w", err)
	}
	return out.Bytes(), nil
}

// decodeOpenAPISpecCached returns a closure that caches the decoded spec.
func decodeOpenAPISpecCached() func() ([]byte, error) {
	var cached []byte
	var cachedErr error
	var once sync.Once
	return func() ([]byte, error) {
		once.Do(func() {
			cached, cachedErr = decodeOpenAPISpec()
		})
		return cached, cachedErr
	}
}

var openAPISpec = decodeOpenAPISpecCached()

// GetOpenAPISpecJSON returns the raw OpenAPI spec as JSON bytes.
func GetOpenAPISpecJSON() ([]byte, error) {
	return openAPISpec()
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Deregister a webhook
	// (DELETE /api/webhook/{id})
	DeregisterWebhook(w http.ResponseWriter, r *http.Request, id uuid.UUID)
	// Register a webhook
	// (POST /api/webhook/{kind})
	RegisterWebhook(w http.ResponseWriter, r *http.Request, kind string)
}

// ServerInterfaceWrapper converts HTTP requests to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

// MiddlewareFunc is a middleware function type.
type MiddlewareFunc func(http.Handler) http.Handler

// DeregisterWebhook operation middleware
func (siw *ServerInterfaceWrapper) DeregisterWebhook(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "id" -------------
	var id uuid.UUID

	err = BindSimpleParam("id", ParamLocationPath, r.PathValue("id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeregisterWebhook(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RegisterWebhook operation middleware
func (siw *ServerInterfaceWrapper) RegisterWebhook(w http.ResponseWriter, r *http.Request) {
	var err error

	// ------------- Path parameter "kind" -------------
	var kind string

	err = BindSimpleParam("kind", ParamLocationPath, r.PathValue("kind"), &kind)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterWebhook(w, r, kind)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

// StdHTTPServerOptions configures the StdHTTP server.
type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

// HandlerFromMuxWithBaseURL creates http.Handler with routing and a base URL.
func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options.
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("DELETE "+options.BaseURL+"/api/webhook/{id}", wrapper.DeregisterWebhook)
	m.HandleFunc("POST "+options.BaseURL+"/api/webhook/{kind}", wrapper.RegisterWebhook)
	return m
}

// UnescapedCookieParamError is returned when a cookie parameter cannot be unescaped.
type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

// UnmarshalingParamError is returned when a parameter cannot be unmarshaled.
type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

// RequiredParamError is returned when a required parameter is missing.
type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

// RequiredHeaderError is returned when a required header is missing.
type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

// InvalidParamFormatError is returned when a parameter has an invalid format.
type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

// TooManyValuesForParamError is returned when a parameter has too many values.
type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// ParamLocation indicates where a parameter is located in an HTTP request.
type ParamLocation int

const (
	ParamLocationUndefined ParamLocation = iota
	ParamLocationQuery
	ParamLocationPath
	ParamLocationHeader
	ParamLocationCookie
)

// Binder is an interface for types that can bind themselves from a string value.
type Binder interface {
	Bind(value string) error
}

// DateFormat is the format used for date (without time) parameters.
const DateFormat = "2006-01-02"

// Date represents a date (without time) for OpenAPI date format.
type Date struct {
	time.Time
}

// UnmarshalText implements encoding.TextUnmarshaler for Date.
func (d *Date) UnmarshalText(data []byte) error {
	t, err := time.Parse(DateFormat, string(data))
	if err != nil {
		return err
	}
	d.Time = t
	return nil
}

// MarshalText implements encoding.TextMarshaler for Date.
func (d Date) MarshalText() ([]byte, error) {
	return []byte(d.Format(DateFormat)), nil
}

// Format returns the date formatted according to layout.
func (d Date) Format(layout string) string {
	return d.Time.Format(layout)
}

// primitiveToString converts a primitive value to a string representation.
// It handles basic Go types, time.Time, types.Date, and types that implement
// json.Marshaler or fmt.Stringer.
func primitiveToString(value any) (string, error) {
	// Check for known types first (time, date, uuid)
	if res, ok := marshalKnownTypes(value); ok {
		return res, nil
	}

	// Dereference pointers for optional values
	v := reflect.Indirect(reflect.ValueOf(value))
	t := v.Type()
	kind := t.Kind()

	switch kind {
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
		return strconv.FormatInt(v.Int(), 10), nil
	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
		return strconv.FormatUint(v.Uint(), 10), nil
	case reflect.Float64:
		return strconv.FormatFloat(v.Float(), 'f', -1, 64), nil
	case reflect.Float32:
		return strconv.FormatFloat(v.Float(), 'f', -1, 32), nil
	case reflect.Bool:
		if v.Bool() {
			return "true", nil
		}
		return "false", nil
	case reflect.String:
		return v.String(), nil
	case reflect.Struct:
		// Check if it's a UUID
		if u, ok := value.(uuid.UUID); ok {
			return u.String(), nil
		}
		// Check if it implements json.Marshaler
		if m, ok := value.(json.Marshaler); ok {
			buf, err := m.MarshalJSON()
			if err != nil {
				return "", fmt.Errorf("failed to marshal to JSON: %w", err)
			}
			e := json.NewDecoder(bytes.NewReader(buf))
			e.UseNumber()
			var i2 any
			if err = e.Decode(&i2); err != nil {
				return "", fmt.Errorf("failed to decode JSON: %w", err)
			}
			return primitiveToString(i2)
		}
		fallthrough
	default:
		if s, ok := value.(fmt.Stringer); ok {
			return s.String(), nil
		}
		return "", fmt.Errorf("unsupported type %s", reflect.TypeOf(value).String())
	}
}

// marshalKnownTypes checks for special types (time.Time, Date, UUID) and marshals them.
func marshalKnownTypes(value any) (string, bool) {
	v := reflect.Indirect(reflect.ValueOf(value))
	t := v.Type()

	if t.ConvertibleTo(reflect.TypeOf(time.Time{})) {
		tt := v.Convert(reflect.TypeOf(time.Time{}))
		timeVal := tt.Interface().(time.Time)
		return timeVal.Format(time.RFC3339Nano), true
	}

	if t.ConvertibleTo(reflect.TypeOf(Date{})) {
		d := v.Convert(reflect.TypeOf(Date{}))
		dateVal := d.Interface().(Date)
		return dateVal.Format(DateFormat), true
	}

	if t.ConvertibleTo(reflect.TypeOf(uuid.UUID{})) {
		u := v.Convert(reflect.TypeOf(uuid.UUID{}))
		uuidVal := u.Interface().(uuid.UUID)
		return uuidVal.String(), true
	}

	return "", false
}

// escapeParameterString escapes a parameter value based on its location.
// Query and path parameters need URL escaping; headers and cookies do not.
func escapeParameterString(value string, paramLocation ParamLocation) string {
	switch paramLocation {
	case ParamLocationQuery:
		return url.QueryEscape(value)
	case ParamLocationPath:
		return url.PathEscape(value)
	default:
		return value
	}
}

// unescapeParameterString unescapes a parameter value based on its location.
func unescapeParameterString(value string, paramLocation ParamLocation) (string, error) {
	switch paramLocation {
	case ParamLocationQuery, ParamLocationUndefined:
		return url.QueryUnescape(value)
	case ParamLocationPath:
		return url.PathUnescape(value)
	default:
		return value, nil
	}
}

// sortedKeys returns the keys of a map in sorted order.
func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// BindStringToObject binds a string value to a destination object.
// It handles primitives, encoding.TextUnmarshaler, and the Binder interface.
func BindStringToObject(src string, dst any) error {
	// Check for TextUnmarshaler
	if tu, ok := dst.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(src))
	}

	// Check for Binder interface
	if b, ok := dst.(Binder); ok {
		return b.Bind(src)
	}

	v := reflect.ValueOf(dst)
	if v.Kind() != reflect.Ptr {
		return fmt.Errorf("dst must be a pointer, got %T", dst)
	}
	v = v.Elem()

	switch v.Kind() {
	case reflect.String:
		v.SetString(src)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		i, err := strconv.ParseInt(src, 10, 64)
		if err != nil {
			return fmt.Errorf("failed to parse int: %w", err)
		}
		v.SetInt(i)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		u, err := strconv.ParseUint(src, 10, 64)
		if err != nil {
			return fmt.Errorf("failed to parse uint: %w", err)
		}
		v.SetUint(u)
	case reflect.Float32, reflect.Float64:
		f, err := strconv.ParseFloat(src, 64)
		if err != nil {
			return fmt.Errorf("failed to parse float: %w", err)
		}
		v.SetFloat(f)
	case reflect.Bool:
		b, err := strconv.ParseBool(src)
		if err != nil {
			return fmt.Errorf("failed to parse bool: %w", err)
		}
		v.SetBool(b)
	default:
		// Try JSON unmarshal as a fallback
		return json.Unmarshal([]byte(src), dst)
	}
	return nil
}

// bindSplitPartsToDestinationArray binds a slice of string parts to a destination slice.
func bindSplitPartsToDestinationArray(parts []string, dest any) error {
	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	newArray := reflect.MakeSlice(t, len(parts), len(parts))
	for i, p := range parts {
		err := BindStringToObject(p, newArray.Index(i).Addr().Interface())
		if err != nil {
			return fmt.Errorf("error setting array element: %w", err)
		}
	}
	v.Set(newArray)
	return nil
}

// bindSplitPartsToDestinationStruct binds string parts to a destination struct via JSON.
func bindSplitPartsToDestinationStruct(paramName string, parts []string, explode bool, dest any) error {
	var fields []string
	if explode {
		fields = make([]string, len(parts))
		for i, property := range parts {
			propertyParts := strings.Split(property, "=")
			if len(propertyParts) != 2 {
				return fmt.Errorf("parameter '%s' has invalid exploded format", paramName)
			}
			fields[i] = "\"" + propertyParts[0] + "\":\"" + propertyParts[1] + "\""
		}
	} else {
		if len(parts)%2 != 0 {
			return fmt.Errorf("parameter '%s' has invalid format, property/values need to be pairs", paramName)
		}
		fields = make([]string, len(parts)/2)
		for i := 0; i < len(parts); i += 2 {
			key := parts[i]
			value := parts[i+1]
			fields[i/2] = "\"" + key + "\":\"" + value + "\""
		}
	}
	jsonParam := "{" + strings.Join(fields, ",") + "}"
	return json.Unmarshal([]byte(jsonParam), dest)
}

// BindSimpleParam binds a simple-style parameter without explode to a destination.
// Simple style is the default for path and header parameters.
// Arrays: a,b,c -> []string{"a", "b", "c"}
// Objects: key1,value1,key2,value2 -> struct{Key1, Key2}
func BindSimpleParam(paramName string, paramLocation ParamLocation, value string, dest any) error {
	if value == "" {
		return fmt.Errorf("parameter '%s' is empty, can't bind its value", paramName)
	}

	// Unescape based on location
	var err error
	value, err = unescapeParameterString(value, paramLocation)
	if err != nil {
		return fmt.Errorf("error unescaping parameter '%s': %w", paramName, err)
	}

	// Check for TextUnmarshaler
	if tu, ok := dest.(encoding.TextUnmarshaler); ok {
		return tu.UnmarshalText([]byte(value))
	}

	v := reflect.Indirect(reflect.ValueOf(dest))
	t := v.Type()

	switch t.Kind() {
	case reflect.Struct:
		// Split on comma and bind as key,value pairs
		parts := strings.Split(value, ",")
		return bindSplitPartsToDestinationStruct(paramName, parts, false, dest)
	case reflect.Slice:
		parts := strings.Split(value, ",")
		return bindSplitPartsToDestinationArray(parts, dest)
	default:
		return BindStringToObject(value, dest)
	}
}

// StyleSimpleParam serializes a value using simple style (RFC 6570) without exploding.
// Simple style is the default for path and header parameters.
// Arrays are comma-separated: a,b,c
// Objects are key,value pairs: key1,value1,key2,value2
func StyleSimpleParam(paramName string, paramLocation ParamLocation, value any) (string, error) {
	t := reflect.TypeOf(value)
	v := reflect.ValueOf(value)

	// Dereference pointers
	if t.Kind() == reflect.Ptr {
		if v.IsNil() {
			return "", fmt.Errorf("value is a nil pointer")
		}
		v = reflect.Indirect(v)
		t = v.Type()
	}

	// Check for TextMarshaler (but not time.Time or Date)
	if tu, ok := value.(encoding.TextMarshaler); ok {
		innerT := reflect.Indirect(reflect.ValueOf(value)).Type()
		if !innerT.ConvertibleTo(reflect.TypeOf(time.Time{})) && !innerT.ConvertibleTo(reflect.TypeOf(Date{})) {
			b, err := tu.MarshalText()
			if err != nil {
				return "", fmt.Errorf("error marshaling '%s' as text: %w", value, err)
			}
			return escapeParameterString(string(b), paramLocation), nil
		}
	}

	switch t.Kind() {
	case reflect.Slice:
		n := v.Len()
		sliceVal := make([]any, n)
		for i := 0; i < n; i++ {
			sliceVal[i] = v.Index(i).Interface()
		}
		return styleSimpleSlice(paramName, paramLocation, sliceVal)
	case reflect.Struct:
		return styleSimpleStruct(paramName, paramLocation, value)
	case reflect.Map:
		return styleSimpleMap(paramName, paramLocation, value)
	default:
		return styleSimplePrimitive(paramLocation, value)
	}
}

func styleSimplePrimitive(paramLocation ParamLocation, value any) (string, error) {
	strVal, err := primitiveToString(value)
	if err != nil {
		return "", err
	}
	return escapeParameterString(strVal, paramLocation), nil
}

func styleSimpleSlice(paramName string, paramLocation ParamLocation, values []any) (string, error) {
	parts := make([]string, len(values))
	for i, v := range values {
		part, err := primitiveToString(v)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		parts[i] = escapeParameterString(part, paramLocation)
	}
	return strings.Join(parts, ","), nil
}

func styleSimpleStruct(paramName string, paramLocation ParamLocation, value any) (string, error) {
	// Check for known types first
	if timeVal, ok := marshalKnownTypes(value); ok {
		return escapeParameterString(timeVal, paramLocation), nil
	}

	// Check for json.Marshaler
	if m, ok := value.(json.Marshaler); ok {
		buf, err := m.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal to JSON: %w", err)
		}
		var i2 any
		e := json.NewDecoder(bytes.NewReader(buf))
		e.UseNumber()
		if err = e.Decode(&i2); err != nil {
			return "", fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
		return StyleSimpleParam(paramName, paramLocation, i2)
	}

	// Build field dictionary
	fieldDict, err := structToFieldDict(value)
	if err != nil {
		return "", err
	}

	// Simple style without explode: key1,value1,key2,value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return strings.Join(parts, ","), nil
}

func styleSimpleMap(paramName string, paramLocation ParamLocation, value any) (string, error) {
	dict, ok := value.(map[string]any)
	if !ok {
		return "", errors.New("map not of type map[string]any")
	}

	fieldDict := make(map[string]string)
	for fieldName, val := range dict {
		str, err := primitiveToString(val)
		if err != nil {
			return "", fmt.Errorf("error formatting '%s': %w", paramName, err)
		}
		fieldDict[fieldName] = str
	}

	// Simple style without explode: key1,value1,key2,value2
	var parts []string
	for _, k := range sortedKeys(fieldDict) {
		v := escapeParameterString(fieldDict[k], paramLocation)
		parts = append(parts, k, v)
	}
	return strings.Join(parts, ","), nil
}

// structToFieldDict converts a struct to a map of field names to string values.
func structToFieldDict(value any) (map[string]string, error) {
	v := reflect.ValueOf(value)
	t := reflect.TypeOf(value)
	fieldDict := make(map[string]string)

	for i := 0; i < t.NumField(); i++ {
		fieldT := t.Field(i)
		tag := fieldT.Tag.Get("json")
		fieldName := fieldT.Name
		if tag != "" {
			tagParts := strings.Split(tag, ",")
			if tagParts[0] != "" {
				fieldName = tagParts[0]
			}
		}
		f := v.Field(i)

		// Skip nil optional fields
		if f.Type().Kind() == reflect.Ptr && f.IsNil() {
			continue
		}
		str, err := primitiveToString(f.Interface())
		if err != nil {
			return nil, fmt.Errorf("error formatting field '%s': %w", fieldName, err)
		}
		fieldDict[fieldName] = str
	}
	return fieldDict, nil
}

type EnterEventJSONRequestBody = Person

type ExitEventJSONRequestBody = Person

// RequestEditorFn is the function signature for the RequestEditor callback function.
// It may already be defined if client code is also generated; this is a compatible redeclaration.
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// HttpRequestDoer performs HTTP requests.
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// WebhookInitiator sends webhook requests to target URLs.
// Unlike Client, it has no stored base URL â€” the full target URL is provided per-call.
type WebhookInitiator struct {
	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// WebhookInitiatorOption allows setting custom parameters during construction.
type WebhookInitiatorOption func(*WebhookInitiator) error

// NewWebhookInitiator creates a new WebhookInitiator with reasonable defaults.
func NewWebhookInitiator(opts ...WebhookInitiatorOption) (*WebhookInitiator, error) {
	initiator := WebhookInitiator{}
	for _, o := range opts {
		if err := o(&initiator); err != nil {
			return nil, err
		}
	}
	if initiator.Client == nil {
		initiator.Client = &http.Client{}
	}
	return &initiator, nil
}

// WithWebhookHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithWebhookHTTPClient(doer HttpRequestDoer) WebhookInitiatorOption {
	return func(p *WebhookInitiator) error {
		p.Client = doer
		return nil
	}
}

// WithWebhookRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithWebhookRequestEditorFn(fn RequestEditorFn) WebhookInitiatorOption {
	return func(p *WebhookInitiator) error {
		p.RequestEditors = append(p.RequestEditors, fn)
		return nil
	}
}

func (p *WebhookInitiator) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range p.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// WebhookInitiatorInterface is the interface specification for the webhook initiator.
type WebhookInitiatorInterface interface {
	// EnterEventWithBody sends a POST webhook request
	EnterEventWithBody(ctx context.Context, targetURL string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
	EnterEvent(ctx context.Context, targetURL string, body EnterEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
	// ExitEventWithBody sends a POST webhook request
	ExitEventWithBody(ctx context.Context, targetURL string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
	ExitEvent(ctx context.Context, targetURL string, body ExitEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

// EnterEventWithBody sends a POST webhook request
// Person entered the building
func (p *WebhookInitiator) EnterEventWithBody(ctx context.Context, targetURL string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterEventWebhookRequestWithBody(targetURL, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := p.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return p.Client.Do(req)
}

// EnterEvent sends a POST webhook request with JSON body
func (p *WebhookInitiator) EnterEvent(ctx context.Context, targetURL string, body EnterEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterEventWebhookRequest(targetURL, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := p.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return p.Client.Do(req)
}

// ExitEventWithBody sends a POST webhook request
// Person exited the building
func (p *WebhookInitiator) ExitEventWithBody(ctx context.Context, targetURL string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitEventWebhookRequestWithBody(targetURL, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := p.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return p.Client.Do(req)
}

// ExitEvent sends a POST webhook request with JSON body
func (p *WebhookInitiator) ExitEvent(ctx context.Context, targetURL string, body ExitEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitEventWebhookRequest(targetURL, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := p.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return p.Client.Do(req)
}

// NewEnterEventWebhookRequest creates a POST request for the webhook with application/json body
func NewEnterEventWebhookRequest(targetURL string, body EnterEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterEventWebhookRequestWithBody(targetURL, "application/json", bodyReader)
}

// NewEnterEventWebhookRequestWithBody creates a POST request for the webhook with any body
func NewEnterEventWebhookRequestWithBody(targetURL string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", parsedURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExitEventWebhookRequest creates a POST request for the webhook with application/json body
func NewExitEventWebhookRequest(targetURL string, body ExitEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExitEventWebhookRequestWithBody(targetURL, "application/json", bodyReader)
}

// NewExitEventWebhookRequestWithBody creates a POST request for the webhook with any body
func NewExitEventWebhookRequestWithBody(targetURL string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", parsedURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// WebhookHttpError represents an HTTP error response.
// The type parameter E is the type of the parsed error body.
type WebhookHttpError[E any] struct {
	StatusCode int
	Body       E
	RawBody    []byte
}

func (e *WebhookHttpError[E]) Error() string {
	return fmt.Sprintf("HTTP %d", e.StatusCode)
}

// SimpleWebhookInitiator wraps WebhookInitiator with typed responses for operations that have
// unambiguous response types. Methods return the success type directly,
// and HTTP errors are returned as *WebhookHttpError[E] where E is the error type.
type SimpleWebhookInitiator struct {
	*WebhookInitiator
}

// NewSimpleWebhookInitiator creates a new SimpleWebhookInitiator which wraps a WebhookInitiator.
func NewSimpleWebhookInitiator(opts ...WebhookInitiatorOption) (*SimpleWebhookInitiator, error) {
	initiator, err := NewWebhookInitiator(opts...)
	if err != nil {
		return nil, err
	}
	return &SimpleWebhookInitiator{WebhookInitiator: initiator}, nil
}

// WebhookReceiverInterface represents handlers for receiving webhook requests.
type WebhookReceiverInterface interface {
	// Person entered the building
	// HandleEnterEventWebhook handles the POST webhook request.
	HandleEnterEventWebhook(w http.ResponseWriter, r *http.Request)
	// Person exited the building
	// HandleExitEventWebhook handles the POST webhook request.
	HandleExitEventWebhook(w http.ResponseWriter, r *http.Request)
}

// WebhookReceiverMiddlewareFunc is a middleware function for webhook receiver handlers.
type WebhookReceiverMiddlewareFunc func(http.Handler) http.Handler

// EnterEventWebhookHandler returns an http.Handler for the EnterEvent webhook.
// The caller is responsible for registering this handler at the appropriate path.
func EnterEventWebhookHandler(si WebhookReceiverInterface, errHandler func(w http.ResponseWriter, r *http.Request, err error), middlewares ...WebhookReceiverMiddlewareFunc) http.Handler {
	if errHandler == nil {
		errHandler = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			si.HandleEnterEventWebhook(w, r)
		}))

		for _, middleware := range middlewares {
			handler = middleware(handler)
		}

		handler.ServeHTTP(w, r)
	})
}

// ExitEventWebhookHandler returns an http.Handler for the ExitEvent webhook.
// The caller is responsible for registering this handler at the appropriate path.
func ExitEventWebhookHandler(si WebhookReceiverInterface, errHandler func(w http.ResponseWriter, r *http.Request, err error), middlewares ...WebhookReceiverMiddlewareFunc) http.Handler {
	if errHandler == nil {
		errHandler = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			si.HandleExitEventWebhook(w, r)
		}))

		for _, middleware := range middlewares {
			handler = middleware(handler)
		}

		handler.ServeHTTP(w, r)
	})
}
