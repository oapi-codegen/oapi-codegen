// Package discriminator provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package discriminator

import (
	"encoding/json"
	"errors"
	"fmt"

	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Animal defines model for Animal.
type Animal struct {
	AnimalType       string          `json:"animalType"`
	Id               *string         `json:"id,omitempty"`
	Name             string          `json:"name"`
	discriminatorRaw json.RawMessage `json:"-"`
}

// BaseActivity defines model for BaseActivity.
type BaseActivity struct {
	Duration int     `json:"duration"`
	Id       *string `json:"id,omitempty"`
}

// BaseHealthRecord defines model for BaseHealthRecord.
type BaseHealthRecord struct {
	Date openapi_types.Date `json:"date"`
	Id   *string            `json:"id,omitempty"`
}

// Cat defines model for Cat.
type Cat struct {
	Id      *string `json:"id,omitempty"`
	Meow    *bool   `json:"meow,omitempty"`
	Name    string  `json:"name"`
	PetType string  `json:"petType"`
}

// CheckupRecord defines model for CheckupRecord.
type CheckupRecord struct {
	Date       openapi_types.Date `json:"date"`
	Id         *string            `json:"id,omitempty"`
	RecordType string             `json:"recordType"`
	Weight     float32            `json:"weight"`
}

// Dog defines model for Dog.
type Dog struct {
	Bark    *bool   `json:"bark,omitempty"`
	Id      *string `json:"id,omitempty"`
	Name    string  `json:"name"`
	PetType string  `json:"petType"`
}

// DomesticAnimal defines model for DomesticAnimal.
type DomesticAnimal struct {
	AnimalType       string          `json:"animalType"`
	DomesticType     string          `json:"domesticType"`
	Id               *string         `json:"id,omitempty"`
	Name             string          `json:"name"`
	Owner            *string         `json:"owner,omitempty"`
	discriminatorRaw json.RawMessage `json:"-"`
}

// FeedingActivity defines model for FeedingActivity.
type FeedingActivity struct {
	ActivityType string  `json:"activityType"`
	Duration     int     `json:"duration"`
	FoodType     string  `json:"foodType"`
	Id           *string `json:"id,omitempty"`
}

// HealthRecord defines model for HealthRecord.
type HealthRecord struct {
	Date             openapi_types.Date `json:"date"`
	Id               *string            `json:"id,omitempty"`
	RecordType       string             `json:"recordType"`
	discriminatorRaw json.RawMessage    `json:"-"`
}

// HouseCat defines model for HouseCat.
type HouseCat struct {
	AnimalType   string  `json:"animalType"`
	DomesticType string  `json:"domesticType"`
	Id           *string `json:"id,omitempty"`
	Indoor       *bool   `json:"indoor,omitempty"`
	Name         string  `json:"name"`
	Owner        *string `json:"owner,omitempty"`
}

// HouseDog defines model for HouseDog.
type HouseDog struct {
	AnimalType   string  `json:"animalType"`
	DomesticType string  `json:"domesticType"`
	Id           *string `json:"id,omitempty"`
	Name         string  `json:"name"`
	Owner        *string `json:"owner,omitempty"`
	Trained      *bool   `json:"trained,omitempty"`
}

// Lion defines model for Lion.
type Lion struct {
	AnimalType string  `json:"animalType"`
	Habitat    *string `json:"habitat,omitempty"`
	Id         *string `json:"id,omitempty"`
	ManeColor  string  `json:"maneColor"`
	Name       string  `json:"name"`
	WildType   string  `json:"wildType"`
}

// Pet defines model for Pet.
type Pet struct {
	Id               *string         `json:"id,omitempty"`
	Name             string          `json:"name"`
	PetType          string          `json:"petType"`
	discriminatorRaw json.RawMessage `json:"-"`
}

// PetActivity defines model for PetActivity.
type PetActivity struct {
	ActivityType     string          `json:"activityType"`
	Duration         int             `json:"duration"`
	Id               *string         `json:"id,omitempty"`
	discriminatorRaw json.RawMessage `json:"-"`
}

// Tiger defines model for Tiger.
type Tiger struct {
	AnimalType  string  `json:"animalType"`
	Habitat     *string `json:"habitat,omitempty"`
	Id          *string `json:"id,omitempty"`
	Name        string  `json:"name"`
	StripeCount *int    `json:"stripeCount,omitempty"`
	WildType    string  `json:"wildType"`
}

// VaccinationRecord defines model for VaccinationRecord.
type VaccinationRecord struct {
	Date       openapi_types.Date `json:"date"`
	Id         *string            `json:"id,omitempty"`
	RecordType string             `json:"recordType"`
	Vaccine    string             `json:"vaccine"`
}

// WalkingActivity defines model for WalkingActivity.
type WalkingActivity struct {
	ActivityType string  `json:"activityType"`
	Distance     float32 `json:"distance"`
	Duration     int     `json:"duration"`
	Id           *string `json:"id,omitempty"`
}

// WildAnimal defines model for WildAnimal.
type WildAnimal struct {
	AnimalType       string          `json:"animalType"`
	Habitat          *string         `json:"habitat,omitempty"`
	Id               *string         `json:"id,omitempty"`
	Name             string          `json:"name"`
	WildType         string          `json:"wildType"`
	discriminatorRaw json.RawMessage `json:"-"`
}

// RegisterAnimalJSONRequestBody defines body for RegisterAnimal for application/json ContentType.
type RegisterAnimalJSONRequestBody = Animal

// CreatePetJSONRequestBody defines body for CreatePet for application/json ContentType.
type CreatePetJSONRequestBody = Pet

// LogActivityJSONRequestBody defines body for LogActivity for application/json ContentType.
type LogActivityJSONRequestBody = PetActivity

// AddHealthRecordJSONRequestBody defines body for AddHealthRecord for application/json ContentType.
type AddHealthRecordJSONRequestBody = HealthRecord

type AnimalInterface interface {
	isAnimal() // unexported method to seal the interface
}

// Discriminator returns the discriminator property value for Animal
func (t *Animal) Discriminator() string {
	return t.AnimalType
}

// isAnimal implements AnimalInterface for DomesticAnimal
func (t DomesticAnimal) isAnimal() {}

// IsDomesticAnimal checks if the discriminator value matches DomesticAnimal
func (t *Animal) IsDomesticAnimal() bool {
	return string(t.AnimalType) == "domestic"
}

// AsDomesticAnimal attempts to convert Animal to DomesticAnimal based on discriminator
func (t *Animal) AsDomesticAnimal() (*DomesticAnimal, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.AnimalType) != "domestic" {
		return nil, fmt.Errorf("discriminator value mismatch: expected domestic, got %v", t.AnimalType)
	}
	var result DomesticAnimal
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as DomesticAnimal: %w", err)
	}
	return &result, nil
}

// isAnimal implements AnimalInterface for WildAnimal
func (t WildAnimal) isAnimal() {}

// IsWildAnimal checks if the discriminator value matches WildAnimal
func (t *Animal) IsWildAnimal() bool {
	return string(t.AnimalType) == "wild"
}

// AsWildAnimal attempts to convert Animal to WildAnimal based on discriminator
func (t *Animal) AsWildAnimal() (*WildAnimal, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.AnimalType) != "wild" {
		return nil, fmt.Errorf("discriminator value mismatch: expected wild, got %v", t.AnimalType)
	}
	var result WildAnimal
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as WildAnimal: %w", err)
	}
	return &result, nil
}

// ValueByDiscriminator returns the concrete type based on the discriminator value
func (t *Animal) ValueByDiscriminator() (interface{}, error) {
	discriminator := string(t.AnimalType)
	switch discriminator {
	case "domestic":
		return t.AsDomesticAnimal()
	case "wild":
		return t.AsWildAnimal()
	default:
		return nil, fmt.Errorf("unknown discriminator value: %v", discriminator)
	}
}

// UnmarshalJSON implements custom unmarshaling to preserve raw JSON for discriminator
func (t *Animal) UnmarshalJSON(data []byte) error {
	// Store raw data for later conversion
	t.discriminatorRaw = make([]byte, len(data))
	copy(t.discriminatorRaw, data)

	// Unmarshal into the base type
	type Alias Animal
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(t),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	return nil
}

type DomesticAnimalInterface interface {
	isDomesticAnimal() // unexported method to seal the interface
}

// Discriminator returns the discriminator property value for DomesticAnimal
func (t *DomesticAnimal) Discriminator() string {
	return t.DomesticType
}

// isDomesticAnimal implements DomesticAnimalInterface for HouseCat
func (t HouseCat) isDomesticAnimal() {}

// IsHouseCat checks if the discriminator value matches HouseCat
func (t *DomesticAnimal) IsHouseCat() bool {
	return string(t.DomesticType) == "housecat"
}

// AsHouseCat attempts to convert DomesticAnimal to HouseCat based on discriminator
func (t *DomesticAnimal) AsHouseCat() (*HouseCat, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.DomesticType) != "housecat" {
		return nil, fmt.Errorf("discriminator value mismatch: expected housecat, got %v", t.DomesticType)
	}
	var result HouseCat
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as HouseCat: %w", err)
	}
	return &result, nil
}

// isDomesticAnimal implements DomesticAnimalInterface for HouseDog
func (t HouseDog) isDomesticAnimal() {}

// IsHouseDog checks if the discriminator value matches HouseDog
func (t *DomesticAnimal) IsHouseDog() bool {
	return string(t.DomesticType) == "housedog"
}

// AsHouseDog attempts to convert DomesticAnimal to HouseDog based on discriminator
func (t *DomesticAnimal) AsHouseDog() (*HouseDog, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.DomesticType) != "housedog" {
		return nil, fmt.Errorf("discriminator value mismatch: expected housedog, got %v", t.DomesticType)
	}
	var result HouseDog
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as HouseDog: %w", err)
	}
	return &result, nil
}

// ValueByDiscriminator returns the concrete type based on the discriminator value
func (t *DomesticAnimal) ValueByDiscriminator() (interface{}, error) {
	discriminator := string(t.DomesticType)
	switch discriminator {
	case "housecat":
		return t.AsHouseCat()
	case "housedog":
		return t.AsHouseDog()
	default:
		return nil, fmt.Errorf("unknown discriminator value: %v", discriminator)
	}
}

// UnmarshalJSON implements custom unmarshaling to preserve raw JSON for discriminator
func (t *DomesticAnimal) UnmarshalJSON(data []byte) error {
	// Store raw data for later conversion
	t.discriminatorRaw = make([]byte, len(data))
	copy(t.discriminatorRaw, data)

	// Unmarshal into the base type
	type Alias DomesticAnimal
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(t),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	return nil
}

type HealthRecordInterface interface {
	isHealthRecord() // unexported method to seal the interface
}

// Discriminator returns the discriminator property value for HealthRecord
func (t *HealthRecord) Discriminator() string {
	return t.RecordType
}

// isHealthRecord implements HealthRecordInterface for CheckupRecord
func (t CheckupRecord) isHealthRecord() {}

// IsCheckupRecord checks if the discriminator value matches CheckupRecord
func (t *HealthRecord) IsCheckupRecord() bool {
	return string(t.RecordType) == "checkup"
}

// AsCheckupRecord attempts to convert HealthRecord to CheckupRecord based on discriminator
func (t *HealthRecord) AsCheckupRecord() (*CheckupRecord, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.RecordType) != "checkup" {
		return nil, fmt.Errorf("discriminator value mismatch: expected checkup, got %v", t.RecordType)
	}
	var result CheckupRecord
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as CheckupRecord: %w", err)
	}
	return &result, nil
}

// isHealthRecord implements HealthRecordInterface for VaccinationRecord
func (t VaccinationRecord) isHealthRecord() {}

// IsVaccinationRecord checks if the discriminator value matches VaccinationRecord
func (t *HealthRecord) IsVaccinationRecord() bool {
	return string(t.RecordType) == "vaccination"
}

// AsVaccinationRecord attempts to convert HealthRecord to VaccinationRecord based on discriminator
func (t *HealthRecord) AsVaccinationRecord() (*VaccinationRecord, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.RecordType) != "vaccination" {
		return nil, fmt.Errorf("discriminator value mismatch: expected vaccination, got %v", t.RecordType)
	}
	var result VaccinationRecord
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as VaccinationRecord: %w", err)
	}
	return &result, nil
}

// ValueByDiscriminator returns the concrete type based on the discriminator value
func (t *HealthRecord) ValueByDiscriminator() (interface{}, error) {
	discriminator := string(t.RecordType)
	switch discriminator {
	case "checkup":
		return t.AsCheckupRecord()
	case "vaccination":
		return t.AsVaccinationRecord()
	default:
		return nil, fmt.Errorf("unknown discriminator value: %v", discriminator)
	}
}

// UnmarshalJSON implements custom unmarshaling to preserve raw JSON for discriminator
func (t *HealthRecord) UnmarshalJSON(data []byte) error {
	// Store raw data for later conversion
	t.discriminatorRaw = make([]byte, len(data))
	copy(t.discriminatorRaw, data)

	// Unmarshal into the base type
	type Alias HealthRecord
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(t),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	return nil
}

type PetInterface interface {
	isPet() // unexported method to seal the interface
}

// Discriminator returns the discriminator property value for Pet
func (t *Pet) Discriminator() string {
	return t.PetType
}

// isPet implements PetInterface for Cat
func (t Cat) isPet() {}

// IsCat checks if the discriminator value matches Cat
func (t *Pet) IsCat() bool {
	return string(t.PetType) == "cat"
}

// AsCat attempts to convert Pet to Cat based on discriminator
func (t *Pet) AsCat() (*Cat, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.PetType) != "cat" {
		return nil, fmt.Errorf("discriminator value mismatch: expected cat, got %v", t.PetType)
	}
	var result Cat
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as Cat: %w", err)
	}
	return &result, nil
}

// isPet implements PetInterface for Dog
func (t Dog) isPet() {}

// IsDog checks if the discriminator value matches Dog
func (t *Pet) IsDog() bool {
	return string(t.PetType) == "dog"
}

// AsDog attempts to convert Pet to Dog based on discriminator
func (t *Pet) AsDog() (*Dog, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.PetType) != "dog" {
		return nil, fmt.Errorf("discriminator value mismatch: expected dog, got %v", t.PetType)
	}
	var result Dog
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as Dog: %w", err)
	}
	return &result, nil
}

// ValueByDiscriminator returns the concrete type based on the discriminator value
func (t *Pet) ValueByDiscriminator() (interface{}, error) {
	discriminator := string(t.PetType)
	switch discriminator {
	case "cat":
		return t.AsCat()
	case "dog":
		return t.AsDog()
	default:
		return nil, fmt.Errorf("unknown discriminator value: %v", discriminator)
	}
}

// UnmarshalJSON implements custom unmarshaling to preserve raw JSON for discriminator
func (t *Pet) UnmarshalJSON(data []byte) error {
	// Store raw data for later conversion
	t.discriminatorRaw = make([]byte, len(data))
	copy(t.discriminatorRaw, data)

	// Unmarshal into the base type
	type Alias Pet
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(t),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	return nil
}

type PetActivityInterface interface {
	isPetActivity() // unexported method to seal the interface
}

// Discriminator returns the discriminator property value for PetActivity
func (t *PetActivity) Discriminator() string {
	return t.ActivityType
}

// isPetActivity implements PetActivityInterface for FeedingActivity
func (t FeedingActivity) isPetActivity() {}

// IsFeedingActivity checks if the discriminator value matches FeedingActivity
func (t *PetActivity) IsFeedingActivity() bool {
	return string(t.ActivityType) == "feeding"
}

// AsFeedingActivity attempts to convert PetActivity to FeedingActivity based on discriminator
func (t *PetActivity) AsFeedingActivity() (*FeedingActivity, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.ActivityType) != "feeding" {
		return nil, fmt.Errorf("discriminator value mismatch: expected feeding, got %v", t.ActivityType)
	}
	var result FeedingActivity
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as FeedingActivity: %w", err)
	}
	return &result, nil
}

// isPetActivity implements PetActivityInterface for WalkingActivity
func (t WalkingActivity) isPetActivity() {}

// IsWalkingActivity checks if the discriminator value matches WalkingActivity
func (t *PetActivity) IsWalkingActivity() bool {
	return string(t.ActivityType) == "walking"
}

// AsWalkingActivity attempts to convert PetActivity to WalkingActivity based on discriminator
func (t *PetActivity) AsWalkingActivity() (*WalkingActivity, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.ActivityType) != "walking" {
		return nil, fmt.Errorf("discriminator value mismatch: expected walking, got %v", t.ActivityType)
	}
	var result WalkingActivity
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as WalkingActivity: %w", err)
	}
	return &result, nil
}

// ValueByDiscriminator returns the concrete type based on the discriminator value
func (t *PetActivity) ValueByDiscriminator() (interface{}, error) {
	discriminator := string(t.ActivityType)
	switch discriminator {
	case "feeding":
		return t.AsFeedingActivity()
	case "walking":
		return t.AsWalkingActivity()
	default:
		return nil, fmt.Errorf("unknown discriminator value: %v", discriminator)
	}
}

// UnmarshalJSON implements custom unmarshaling to preserve raw JSON for discriminator
func (t *PetActivity) UnmarshalJSON(data []byte) error {
	// Store raw data for later conversion
	t.discriminatorRaw = make([]byte, len(data))
	copy(t.discriminatorRaw, data)

	// Unmarshal into the base type
	type Alias PetActivity
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(t),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	return nil
}

type WildAnimalInterface interface {
	isWildAnimal() // unexported method to seal the interface
}

// Discriminator returns the discriminator property value for WildAnimal
func (t *WildAnimal) Discriminator() string {
	return t.WildType
}

// isWildAnimal implements WildAnimalInterface for Lion
func (t Lion) isWildAnimal() {}

// IsLion checks if the discriminator value matches Lion
func (t *WildAnimal) IsLion() bool {
	return string(t.WildType) == "lion"
}

// AsLion attempts to convert WildAnimal to Lion based on discriminator
func (t *WildAnimal) AsLion() (*Lion, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.WildType) != "lion" {
		return nil, fmt.Errorf("discriminator value mismatch: expected lion, got %v", t.WildType)
	}
	var result Lion
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as Lion: %w", err)
	}
	return &result, nil
}

// isWildAnimal implements WildAnimalInterface for Tiger
func (t Tiger) isWildAnimal() {}

// IsTiger checks if the discriminator value matches Tiger
func (t *WildAnimal) IsTiger() bool {
	return string(t.WildType) == "tiger"
}

// AsTiger attempts to convert WildAnimal to Tiger based on discriminator
func (t *WildAnimal) AsTiger() (*Tiger, error) {
	if t.discriminatorRaw == nil {
		return nil, errors.New("no raw data available for discriminator conversion")
	}

	if string(t.WildType) != "tiger" {
		return nil, fmt.Errorf("discriminator value mismatch: expected tiger, got %v", t.WildType)
	}
	var result Tiger
	if err := json.Unmarshal(t.discriminatorRaw, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal as Tiger: %w", err)
	}
	return &result, nil
}

// ValueByDiscriminator returns the concrete type based on the discriminator value
func (t *WildAnimal) ValueByDiscriminator() (interface{}, error) {
	discriminator := string(t.WildType)
	switch discriminator {
	case "lion":
		return t.AsLion()
	case "tiger":
		return t.AsTiger()
	default:
		return nil, fmt.Errorf("unknown discriminator value: %v", discriminator)
	}
}

// UnmarshalJSON implements custom unmarshaling to preserve raw JSON for discriminator
func (t *WildAnimal) UnmarshalJSON(data []byte) error {
	// Store raw data for later conversion
	t.discriminatorRaw = make([]byte, len(data))
	copy(t.discriminatorRaw, data)

	// Unmarshal into the base type
	type Alias WildAnimal
	aux := &struct {
		*Alias
	}{
		Alias: (*Alias)(t),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	return nil
}
