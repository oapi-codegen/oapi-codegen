// Package main provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1-0.20251030153953-7378044f5661+dirty DO NOT EDIT.
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	mcp "github.com/modelcontextprotocol/go-sdk/mcp"
)

// NewPet defines model for NewPet.
type NewPet struct {
	// Age Age of the pet in years
	Age *int `json:"age,omitempty"`

	// Breed Breed of the pet
	Breed *string `json:"breed,omitempty"`

	// Name Name of the pet
	Name string `json:"name"`

	// Tag Tag for categorizing the pet
	Tag *string `json:"tag,omitempty"`
}

// Pet defines model for Pet.
type Pet struct {
	// Age Age of the pet in years
	Age *int `json:"age,omitempty"`

	// Breed Breed of the pet
	Breed *string `json:"breed,omitempty"`

	// Id Unique identifier for the pet
	Id string `json:"id"`

	// Name Name of the pet
	Name string `json:"name"`

	// Tag Tag for categorizing the pet
	Tag *string `json:"tag,omitempty"`
}

// UpdatePet defines model for UpdatePet.
type UpdatePet struct {
	// Age Age of the pet in years
	Age *int `json:"age,omitempty"`

	// Breed Breed of the pet
	Breed *string `json:"breed,omitempty"`

	// Name Name of the pet
	Name *string `json:"name,omitempty"`

	// Tag Tag for categorizing the pet
	Tag *string `json:"tag,omitempty"`
}

// ListPetsParams defines parameters for ListPets.
type ListPetsParams struct {
	// Limit Maximum number of pets to return
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Tag Filter pets by tag
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`
}

// CreatePetJSONRequestBody defines body for CreatePet for application/json ContentType.
type CreatePetJSONRequestBody = NewPet

// UpdatePetJSONRequestBody defines body for UpdatePet for application/json ContentType.
type UpdatePetJSONRequestBody = UpdatePet

// MCPHandlerInterface represents all MCP tool handlers.
type MCPHandlerInterface interface {
	// List all pets
	// (GET /pets)
	ListPets(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
	// Create a pet
	// (POST /pets)
	CreatePet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
	// Delete a pet
	// (DELETE /pets/{petId})
	DeletePet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
	// Get a pet by ID
	// (GET /pets/{petId})
	GetPet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
	// Update a pet
	// (PUT /pets/{petId})
	UpdatePet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
}

// MCPServer is the interface that an MCP server must implement.
// *mcp.Server from github.com/modelcontextprotocol/go-sdk/mcp satisfies this interface.
type MCPServer interface {
	AddTool(t *mcp.Tool, h mcp.ToolHandler)
}

// RegisterMCPTools registers all tool handlers with the MCP server.
// The mcpServer parameter should be a *mcp.Server from github.com/modelcontextprotocol/go-sdk/mcp.
// The si parameter implements MCPHandlerInterface with your business logic.
func RegisterMCPTools(mcpServer MCPServer, si MCPHandlerInterface) error {
	// Register ListPets
	{
		tool := &mcp.Tool{
			Name:         "ListPets",
			Description:  "List all pets",
			InputSchema:  json.RawMessage(`{"properties":{"query":{"properties":{"limit":{"description":"Maximum number of pets to return","format":"int32","maximum":100,"minimum":1,"type":"integer"},"tag":{"description":"Filter pets by tag","type":"string"}},"type":"object"}},"type":"object"}`),
			OutputSchema: json.RawMessage(`{"properties":{"nextCursor":{"type":"string"},"pets":{"items":{"properties":{"age":{"description":"Age of the pet in years","type":"integer"},"breed":{"description":"Breed of the pet","type":"string"},"id":{"description":"Unique identifier for the pet","type":"string"},"name":{"description":"Name of the pet","type":"string"},"tag":{"description":"Tag for categorizing the pet","type":"string"}},"required":["id","name"],"type":"object"},"type":"array"}},"required":["pets"],"type":"object"}`),
		}

		handler := func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return si.ListPets(ctx, req)
		}

		mcpServer.AddTool(tool, handler)
	}
	// Register CreatePet
	{
		tool := &mcp.Tool{
			Name:         "CreatePet",
			Description:  "Create a pet",
			InputSchema:  json.RawMessage(`{"properties":{"body":{"properties":{"age":{"description":"Age of the pet in years","type":"integer"},"breed":{"description":"Breed of the pet","type":"string"},"name":{"description":"Name of the pet","type":"string"},"tag":{"description":"Tag for categorizing the pet","type":"string"}},"required":["name"],"type":"object"}},"required":["body"],"type":"object"}`),
			OutputSchema: json.RawMessage(`{"properties":{"age":{"description":"Age of the pet in years","type":"integer"},"breed":{"description":"Breed of the pet","type":"string"},"id":{"description":"Unique identifier for the pet","type":"string"},"name":{"description":"Name of the pet","type":"string"},"tag":{"description":"Tag for categorizing the pet","type":"string"}},"required":["id","name"],"type":"object"}`),
		}

		handler := func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return si.CreatePet(ctx, req)
		}

		mcpServer.AddTool(tool, handler)
	}
	// Register DeletePet
	{
		tool := &mcp.Tool{
			Name:        "DeletePet",
			Description: "Delete a pet",
			InputSchema: json.RawMessage(`{"properties":{"path":{"properties":{"petId":{"description":"The ID of the pet to delete","type":"string"}},"required":["petId"],"type":"object"}},"required":["path"],"type":"object"}`),
		}

		handler := func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return si.DeletePet(ctx, req)
		}

		mcpServer.AddTool(tool, handler)
	}
	// Register GetPet
	{
		tool := &mcp.Tool{
			Name:         "GetPet",
			Description:  "Get a pet by ID",
			InputSchema:  json.RawMessage(`{"properties":{"path":{"properties":{"petId":{"description":"The ID of the pet to retrieve","type":"string"}},"required":["petId"],"type":"object"}},"required":["path"],"type":"object"}`),
			OutputSchema: json.RawMessage(`{"properties":{"age":{"description":"Age of the pet in years","type":"integer"},"breed":{"description":"Breed of the pet","type":"string"},"id":{"description":"Unique identifier for the pet","type":"string"},"name":{"description":"Name of the pet","type":"string"},"tag":{"description":"Tag for categorizing the pet","type":"string"}},"required":["id","name"],"type":"object"}`),
		}

		handler := func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return si.GetPet(ctx, req)
		}

		mcpServer.AddTool(tool, handler)
	}
	// Register UpdatePet
	{
		tool := &mcp.Tool{
			Name:         "UpdatePet",
			Description:  "Update a pet",
			InputSchema:  json.RawMessage(`{"properties":{"body":{"properties":{"age":{"description":"Age of the pet in years","type":"integer"},"breed":{"description":"Breed of the pet","type":"string"},"name":{"description":"Name of the pet","type":"string"},"tag":{"description":"Tag for categorizing the pet","type":"string"}},"type":"object"},"path":{"properties":{"petId":{"description":"The ID of the pet to update","type":"string"}},"required":["petId"],"type":"object"}},"required":["path","body"],"type":"object"}`),
			OutputSchema: json.RawMessage(`{"properties":{"age":{"description":"Age of the pet in years","type":"integer"},"breed":{"description":"Breed of the pet","type":"string"},"id":{"description":"Unique identifier for the pet","type":"string"},"name":{"description":"Name of the pet","type":"string"},"tag":{"description":"Tag for categorizing the pet","type":"string"}},"required":["id","name"],"type":"object"}`),
		}

		handler := func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return si.UpdatePet(ctx, req)
		}

		mcpServer.AddTool(tool, handler)
	}

	return nil
}

type StrictMCPHandlerFunc = func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error)
type StrictMCPMiddlewareFunc = func(f StrictMCPHandlerFunc, operationID string) StrictMCPHandlerFunc

type StrictMCPServerOptions struct {
	RequestErrorHandlerFunc  func(ctx context.Context, err error) *mcp.CallToolResult
	ResponseErrorHandlerFunc func(ctx context.Context, err error) *mcp.CallToolResult
}

func NewStrictMCPHandler(ssi StrictServerInterface, middlewares []StrictMCPMiddlewareFunc) MCPHandlerInterface {
	return &strictMCPHandler{
		ssi:         ssi,
		middlewares: middlewares,
		options: StrictMCPServerOptions{
			RequestErrorHandlerFunc: func(ctx context.Context, err error) *mcp.CallToolResult {
				return &mcp.CallToolResult{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Request error: %v", err),
						},
					},
					IsError: true,
				}
			},
			ResponseErrorHandlerFunc: func(ctx context.Context, err error) *mcp.CallToolResult {
				return &mcp.CallToolResult{
					Content: []mcp.Content{
						&mcp.TextContent{
							Text: fmt.Sprintf("Response error: %v", err),
						},
					},
					IsError: true,
				}
			},
		},
	}
}

func NewStrictMCPHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMCPMiddlewareFunc, options StrictMCPServerOptions) MCPHandlerInterface {
	return &strictMCPHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictMCPHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMCPMiddlewareFunc
	options     StrictMCPServerOptions
}

// ListPets operation middleware
func (sh *strictMCPHandler) ListPets(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var strictRequest ListPetsRequestObject

	// Unmarshal MCP request arguments into strict RequestObject
	// MCP uses nested structure: {"path": {...}, "query": {...}, "body": {...}}
	// but strict interface uses flat structure with direct path params and Params field
	if request.Params.Arguments != nil {
		// Parse the nested MCP structure
		var mcpArgs struct {
			Query  map[string]interface{} `json:"query,omitempty"`
			Header map[string]interface{} `json:"header,omitempty"`
			Cookie map[string]interface{} `json:"cookie,omitempty"`
		}

		argsBytes, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error marshaling arguments: %w", err)), nil
		}
		if err := json.Unmarshal(argsBytes, &mcpArgs); err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error unmarshaling arguments: %w", err)), nil
		}

		// Map path parameters directly to RequestObject fields
		// Map query/header/cookie parameters to Params struct
		paramsData := make(map[string]interface{})
		for k, v := range mcpArgs.Query {
			paramsData[k] = v
		}
		for k, v := range mcpArgs.Header {
			paramsData[k] = v
		}
		for k, v := range mcpArgs.Cookie {
			paramsData[k] = v
		}
		if len(paramsData) > 0 {
			paramsBytes, _ := json.Marshal(paramsData)
			json.Unmarshal(paramsBytes, &strictRequest.Params)
		}
	}

	handler := func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		response, err := sh.ssi.ListPets(ctx, strictRequest)
		if err != nil {
			return nil, err
		}

		// Marshal response and wrap in MCP CallToolResult
		result := &mcp.CallToolResult{}
		if response != nil {
			responseBytes, err := json.Marshal(response)
			if err != nil {
				return sh.options.ResponseErrorHandlerFunc(ctx, fmt.Errorf("error marshaling response: %w", err)), nil
			}
			result.Content = []mcp.Content{
				&mcp.TextContent{
					Text: string(responseBytes),
				},
			}
		}
		return result, nil
	}

	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPets")
	}

	return handler(ctx, request)
}

// CreatePet operation middleware
func (sh *strictMCPHandler) CreatePet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var strictRequest CreatePetRequestObject

	// Unmarshal MCP request arguments into strict RequestObject
	// MCP uses nested structure: {"path": {...}, "query": {...}, "body": {...}}
	// but strict interface uses flat structure with direct path params and Params field
	if request.Params.Arguments != nil {
		// Parse the nested MCP structure
		var mcpArgs struct {
			Body interface{} `json:"body,omitempty"`
		}

		argsBytes, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error marshaling arguments: %w", err)), nil
		}
		if err := json.Unmarshal(argsBytes, &mcpArgs); err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error unmarshaling arguments: %w", err)), nil
		}

		// Map path parameters directly to RequestObject fields
		// Map body
		if mcpArgs.Body != nil {
			bodyBytes, _ := json.Marshal(mcpArgs.Body)
			json.Unmarshal(bodyBytes, &strictRequest.Body)
		}
	}

	handler := func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		response, err := sh.ssi.CreatePet(ctx, strictRequest)
		if err != nil {
			return nil, err
		}

		// Marshal response and wrap in MCP CallToolResult
		result := &mcp.CallToolResult{}
		if response != nil {
			responseBytes, err := json.Marshal(response)
			if err != nil {
				return sh.options.ResponseErrorHandlerFunc(ctx, fmt.Errorf("error marshaling response: %w", err)), nil
			}
			result.Content = []mcp.Content{
				&mcp.TextContent{
					Text: string(responseBytes),
				},
			}
		}
		return result, nil
	}

	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePet")
	}

	return handler(ctx, request)
}

// DeletePet operation middleware
func (sh *strictMCPHandler) DeletePet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var strictRequest DeletePetRequestObject

	// Unmarshal MCP request arguments into strict RequestObject
	// MCP uses nested structure: {"path": {...}, "query": {...}, "body": {...}}
	// but strict interface uses flat structure with direct path params and Params field
	if request.Params.Arguments != nil {
		// Parse the nested MCP structure
		var mcpArgs struct {
			Path map[string]interface{} `json:"path"`
		}

		argsBytes, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error marshaling arguments: %w", err)), nil
		}
		if err := json.Unmarshal(argsBytes, &mcpArgs); err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error unmarshaling arguments: %w", err)), nil
		}

		// Map path parameters directly to RequestObject fields
		if val, ok := mcpArgs.Path["petId"]; ok {
			if strVal, ok := val.(string); ok {
				strictRequest.PetId = strVal
			}
		}
	}

	handler := func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		response, err := sh.ssi.DeletePet(ctx, strictRequest)
		if err != nil {
			return nil, err
		}

		// Marshal response and wrap in MCP CallToolResult
		result := &mcp.CallToolResult{}
		if response != nil {
			responseBytes, err := json.Marshal(response)
			if err != nil {
				return sh.options.ResponseErrorHandlerFunc(ctx, fmt.Errorf("error marshaling response: %w", err)), nil
			}
			result.Content = []mcp.Content{
				&mcp.TextContent{
					Text: string(responseBytes),
				},
			}
		}
		return result, nil
	}

	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePet")
	}

	return handler(ctx, request)
}

// GetPet operation middleware
func (sh *strictMCPHandler) GetPet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var strictRequest GetPetRequestObject

	// Unmarshal MCP request arguments into strict RequestObject
	// MCP uses nested structure: {"path": {...}, "query": {...}, "body": {...}}
	// but strict interface uses flat structure with direct path params and Params field
	if request.Params.Arguments != nil {
		// Parse the nested MCP structure
		var mcpArgs struct {
			Path map[string]interface{} `json:"path"`
		}

		argsBytes, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error marshaling arguments: %w", err)), nil
		}
		if err := json.Unmarshal(argsBytes, &mcpArgs); err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error unmarshaling arguments: %w", err)), nil
		}

		// Map path parameters directly to RequestObject fields
		if val, ok := mcpArgs.Path["petId"]; ok {
			if strVal, ok := val.(string); ok {
				strictRequest.PetId = strVal
			}
		}
	}

	handler := func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		response, err := sh.ssi.GetPet(ctx, strictRequest)
		if err != nil {
			return nil, err
		}

		// Marshal response and wrap in MCP CallToolResult
		result := &mcp.CallToolResult{}
		if response != nil {
			responseBytes, err := json.Marshal(response)
			if err != nil {
				return sh.options.ResponseErrorHandlerFunc(ctx, fmt.Errorf("error marshaling response: %w", err)), nil
			}
			result.Content = []mcp.Content{
				&mcp.TextContent{
					Text: string(responseBytes),
				},
			}
		}
		return result, nil
	}

	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPet")
	}

	return handler(ctx, request)
}

// UpdatePet operation middleware
func (sh *strictMCPHandler) UpdatePet(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var strictRequest UpdatePetRequestObject

	// Unmarshal MCP request arguments into strict RequestObject
	// MCP uses nested structure: {"path": {...}, "query": {...}, "body": {...}}
	// but strict interface uses flat structure with direct path params and Params field
	if request.Params.Arguments != nil {
		// Parse the nested MCP structure
		var mcpArgs struct {
			Path map[string]interface{} `json:"path"`
			Body interface{}            `json:"body,omitempty"`
		}

		argsBytes, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error marshaling arguments: %w", err)), nil
		}
		if err := json.Unmarshal(argsBytes, &mcpArgs); err != nil {
			return sh.options.RequestErrorHandlerFunc(ctx, fmt.Errorf("error unmarshaling arguments: %w", err)), nil
		}

		// Map path parameters directly to RequestObject fields
		if val, ok := mcpArgs.Path["petId"]; ok {
			if strVal, ok := val.(string); ok {
				strictRequest.PetId = strVal
			}
		}
		// Map body
		if mcpArgs.Body != nil {
			bodyBytes, _ := json.Marshal(mcpArgs.Body)
			json.Unmarshal(bodyBytes, &strictRequest.Body)
		}
	}

	handler := func(ctx context.Context, request *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		response, err := sh.ssi.UpdatePet(ctx, strictRequest)
		if err != nil {
			return nil, err
		}

		// Marshal response and wrap in MCP CallToolResult
		result := &mcp.CallToolResult{}
		if response != nil {
			responseBytes, err := json.Marshal(response)
			if err != nil {
				return sh.options.ResponseErrorHandlerFunc(ctx, fmt.Errorf("error marshaling response: %w", err)), nil
			}
			result.Content = []mcp.Content{
				&mcp.TextContent{
					Text: string(responseBytes),
				},
			}
		}
		return result, nil
	}

	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdatePet")
	}

	return handler(ctx, request)
}

type ListPetsRequestObject struct {
	Params ListPetsParams
}

type ListPetsResponseObject interface {
	VisitListPetsResponse(w http.ResponseWriter) error
}

type ListPets200JSONResponse struct {
	NextCursor *string `json:"nextCursor,omitempty"`
	Pets       []Pet   `json:"pets"`
}

func (response ListPets200JSONResponse) VisitListPetsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreatePetRequestObject struct {
	Body *CreatePetJSONRequestBody
}

type CreatePetResponseObject interface {
	VisitCreatePetResponse(w http.ResponseWriter) error
}

type CreatePet201JSONResponse Pet

func (response CreatePet201JSONResponse) VisitCreatePetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type DeletePetRequestObject struct {
	PetId string `json:"petId"`
}

type DeletePetResponseObject interface {
	VisitDeletePetResponse(w http.ResponseWriter) error
}

type DeletePet204Response struct {
}

func (response DeletePet204Response) VisitDeletePetResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeletePet404Response struct {
}

func (response DeletePet404Response) VisitDeletePetResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetPetRequestObject struct {
	PetId string `json:"petId"`
}

type GetPetResponseObject interface {
	VisitGetPetResponse(w http.ResponseWriter) error
}

type GetPet200JSONResponse Pet

func (response GetPet200JSONResponse) VisitGetPetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPet404Response struct {
}

func (response GetPet404Response) VisitGetPetResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type UpdatePetRequestObject struct {
	PetId string `json:"petId"`
	Body  *UpdatePetJSONRequestBody
}

type UpdatePetResponseObject interface {
	VisitUpdatePetResponse(w http.ResponseWriter) error
}

type UpdatePet200JSONResponse Pet

func (response UpdatePet200JSONResponse) VisitUpdatePetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePet404Response struct {
}

func (response UpdatePet404Response) VisitUpdatePetResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// List all pets
	// (GET /pets)
	ListPets(ctx context.Context, request ListPetsRequestObject) (ListPetsResponseObject, error)
	// Create a pet
	// (POST /pets)
	CreatePet(ctx context.Context, request CreatePetRequestObject) (CreatePetResponseObject, error)
	// Delete a pet
	// (DELETE /pets/{petId})
	DeletePet(ctx context.Context, request DeletePetRequestObject) (DeletePetResponseObject, error)
	// Get a pet by ID
	// (GET /pets/{petId})
	GetPet(ctx context.Context, request GetPetRequestObject) (GetPetResponseObject, error)
	// Update a pet
	// (PUT /pets/{petId})
	UpdatePet(ctx context.Context, request UpdatePetRequestObject) (UpdatePetResponseObject, error)
}
